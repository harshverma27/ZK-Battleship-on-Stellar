import {
  require_api,
  require_rpc,
  require_stellar_base_min,
  require_transaction
} from "./chunk-PW27V64E.js";
import {
  __commonJS
} from "./chunk-JVWSFFO4.js";

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/rust_result.js
var require_rust_result = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/rust_result.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Ok = exports.Err = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Ok = exports.Ok = (function() {
      function Ok2(value) {
        _classCallCheck(this, Ok2);
        this.value = value;
      }
      return _createClass(Ok2, [{
        key: "unwrapErr",
        value: function unwrapErr() {
          throw new Error("No error");
        }
      }, {
        key: "unwrap",
        value: function unwrap() {
          return this.value;
        }
      }, {
        key: "isOk",
        value: function isOk() {
          return true;
        }
      }, {
        key: "isErr",
        value: function isErr() {
          return false;
        }
      }]);
    })();
    var Err = exports.Err = (function() {
      function Err2(error) {
        _classCallCheck(this, Err2);
        this.error = error;
      }
      return _createClass(Err2, [{
        key: "unwrapErr",
        value: function unwrapErr() {
          return this.error;
        }
      }, {
        key: "unwrap",
        value: function unwrap() {
          throw new Error(this.error.message);
        }
      }, {
        key: "isOk",
        value: function isOk() {
          return false;
        }
      }, {
        key: "isErr",
        value: function isErr() {
          return true;
        }
      }]);
    })();
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/types.js
var require_types = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NULL_ACCOUNT = exports.DEFAULT_TIMEOUT = void 0;
    var _stellarBase = require_stellar_base_min();
    var DEFAULT_TIMEOUT = exports.DEFAULT_TIMEOUT = 5 * 60;
    var NULL_ACCOUNT = exports.NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF";
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/utils.js
var require_utils = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.contractErrorPattern = void 0;
    exports.getAccount = getAccount;
    exports.implementsToString = implementsToString;
    exports.parseWasmCustomSections = parseWasmCustomSections;
    exports.processSpecEntryStream = processSpecEntryStream;
    exports.withExponentialBackoff = withExponentialBackoff;
    var _stellarBase = require_stellar_base_min();
    var _types = require_types();
    function _regenerator() {
      var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
      function i(r2, n2, o2, i2) {
        var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
        return _regeneratorDefine2(u2, "_invoke", (function(r3, n3, o3) {
          var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d2(t2, r4) {
            return i3 = t2, c3 = 0, u3 = e, G.n = r4, a;
          } };
          function d(r4, n4) {
            for (c3 = r4, u3 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
              var o4, i4 = p[t], d2 = G.p, l = i4[2];
              r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c3 = 0));
            }
            if (o4 || r4 > 1) return a;
            throw y = true, n4;
          }
          return function(o4, p2, l) {
            if (f2 > 1) throw TypeError("Generator is already running");
            for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
              i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
              try {
                if (f2 = 2, i3) {
                  if (c3 || (o4 = "next"), t = i3[o4]) {
                    if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                    if (!t.done) return t;
                    u3 = t.value, c3 < 2 && (c3 = 0);
                  } else 1 === c3 && (t = i3.return) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                  i3 = e;
                } else if ((t = (y = G.n < 0) ? u3 : r3.call(n3, G)) !== a) break;
              } catch (t2) {
                i3 = e, c3 = 1, u3 = t2;
              } finally {
                f2 = 1;
              }
            }
            return { value: t, done: y };
          };
        })(r2, o2, i2), true), u2;
      }
      var a = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t = Object.getPrototypeOf;
      var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function() {
        return this;
      }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
      function f(e2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function() {
        return this;
      }), _regeneratorDefine2(u, "toString", function() {
        return "[object Generator]";
      }), (_regenerator = function _regenerator2() {
        return { w: i, m: f };
      })();
    }
    function _regeneratorDefine2(e, r, n, t) {
      var i = Object.defineProperty;
      try {
        i({}, "", {});
      } catch (e2) {
        i = 0;
      }
      _regeneratorDefine2 = function _regeneratorDefine(e2, r2, n2, t2) {
        function o(r3, n3) {
          _regeneratorDefine2(e2, r3, function(e3) {
            return this._invoke(r3, n3, e3);
          });
        }
        r2 ? i ? i(e2, r2, { value: n2, enumerable: !t2, configurable: !t2, writable: !t2 }) : e2[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
      }, _regeneratorDefine2(e, r, n, t);
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function withExponentialBackoff(_x, _x2, _x3) {
      return _withExponentialBackoff.apply(this, arguments);
    }
    function _withExponentialBackoff() {
      _withExponentialBackoff = _asyncToGenerator(_regenerator().m(function _callee(fn, keepWaitingIf, timeoutInSeconds) {
        var exponentialFactor, verbose, attempts, count, waitUntil, waitTime, totalWaitTime, _args = arguments, _t, _t2;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              exponentialFactor = _args.length > 3 && _args[3] !== void 0 ? _args[3] : 1.5;
              verbose = _args.length > 4 && _args[4] !== void 0 ? _args[4] : false;
              attempts = [];
              count = 0;
              _t = attempts;
              _context.n = 1;
              return fn();
            case 1:
              _t.push.call(_t, _context.v);
              if (keepWaitingIf(attempts[attempts.length - 1])) {
                _context.n = 2;
                break;
              }
              return _context.a(2, attempts);
            case 2:
              waitUntil = new Date(Date.now() + timeoutInSeconds * 1e3).valueOf();
              waitTime = 1e3;
              totalWaitTime = waitTime;
            case 3:
              if (!(Date.now() < waitUntil && keepWaitingIf(attempts[attempts.length - 1]))) {
                _context.n = 6;
                break;
              }
              count += 1;
              if (verbose) {
                console.info("Waiting ".concat(waitTime, "ms before trying again (bringing the total wait time to ").concat(totalWaitTime, "ms so far, of total ").concat(timeoutInSeconds * 1e3, "ms)"));
              }
              _context.n = 4;
              return new Promise(function(res) {
                return setTimeout(res, waitTime);
              });
            case 4:
              waitTime *= exponentialFactor;
              if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {
                waitTime = waitUntil - Date.now();
                if (verbose) {
                  console.info("was gonna wait too long; new waitTime: ".concat(waitTime, "ms"));
                }
              }
              totalWaitTime = waitTime + totalWaitTime;
              _t2 = attempts;
              _context.n = 5;
              return fn(attempts[attempts.length - 1]);
            case 5:
              _t2.push.call(_t2, _context.v);
              if (verbose && keepWaitingIf(attempts[attempts.length - 1])) {
                console.info("".concat(count, ". Called ").concat(fn, "; ").concat(attempts.length, " prev attempts. Most recent: ").concat(JSON.stringify(attempts[attempts.length - 1], null, 2)));
              }
              _context.n = 3;
              break;
            case 6:
              return _context.a(2, attempts);
          }
        }, _callee);
      }));
      return _withExponentialBackoff.apply(this, arguments);
    }
    var contractErrorPattern = exports.contractErrorPattern = /Error\(Contract, #(\d+)\)/;
    function implementsToString(obj) {
      return _typeof(obj) === "object" && obj !== null && "toString" in obj;
    }
    function parseWasmCustomSections(buffer) {
      var sections = /* @__PURE__ */ new Map();
      var arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
      var offset = 0;
      var read = function read2(length) {
        if (offset + length > buffer.byteLength) throw new Error("Buffer overflow");
        var bytes = new Uint8Array(arrayBuffer, offset, length);
        offset += length;
        return bytes;
      };
      function readVarUint32() {
        var value = 0;
        var shift = 0;
        while (true) {
          var byte = read(1)[0];
          value |= (byte & 127) << shift;
          if ((byte & 128) === 0) break;
          if ((shift += 7) >= 32) throw new Error("Invalid WASM value");
        }
        return value >>> 0;
      }
      if (_toConsumableArray(read(4)).join() !== "0,97,115,109") throw new Error("Invalid WASM magic");
      if (_toConsumableArray(read(4)).join() !== "1,0,0,0") throw new Error("Invalid WASM version");
      while (offset < buffer.byteLength) {
        var sectionId = read(1)[0];
        var sectionLength = readVarUint32();
        var start = offset;
        if (sectionId === 0) {
          var nameLen = readVarUint32();
          if (nameLen === 0 || offset + nameLen > start + sectionLength) continue;
          var nameBytes = read(nameLen);
          var payload = read(sectionLength - (offset - start));
          try {
            var name = new TextDecoder("utf-8", {
              fatal: true
            }).decode(nameBytes);
            if (payload.length > 0) {
              sections.set(name, (sections.get(name) || []).concat(payload));
            }
          } catch (_unused) {
          }
        } else {
          offset += sectionLength;
        }
      }
      return sections;
    }
    function processSpecEntryStream(buffer) {
      var reader = new _stellarBase.cereal.XdrReader(buffer);
      var res = [];
      while (!reader.eof) {
        res.push(_stellarBase.xdr.ScSpecEntry.read(reader));
      }
      return res;
    }
    function getAccount(_x4, _x5) {
      return _getAccount.apply(this, arguments);
    }
    function _getAccount() {
      _getAccount = _asyncToGenerator(_regenerator().m(function _callee2(options, server) {
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              return _context2.a(2, options.publicKey ? server.getAccount(options.publicKey) : new _stellarBase.Account(_types.NULL_ACCOUNT, "0"));
          }
        }, _callee2);
      }));
      return _getAccount.apply(this, arguments);
    }
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/sent_transaction.js
var require_sent_transaction = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/sent_transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Watcher = exports.SentTransaction = void 0;
    var _rpc = require_rpc();
    var _api = require_api();
    var _utils = require_utils();
    var _types = require_types();
    var _SentTransaction;
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !_isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return _construct(t2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
      }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regenerator() {
      var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
      function i(r2, n2, o2, i2) {
        var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
        return _regeneratorDefine2(u2, "_invoke", (function(r3, n3, o3) {
          var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d2(t2, r4) {
            return i3 = t2, c3 = 0, u3 = e, G.n = r4, a;
          } };
          function d(r4, n4) {
            for (c3 = r4, u3 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
              var o4, i4 = p[t], d2 = G.p, l = i4[2];
              r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c3 = 0));
            }
            if (o4 || r4 > 1) return a;
            throw y = true, n4;
          }
          return function(o4, p2, l) {
            if (f2 > 1) throw TypeError("Generator is already running");
            for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
              i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
              try {
                if (f2 = 2, i3) {
                  if (c3 || (o4 = "next"), t = i3[o4]) {
                    if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                    if (!t.done) return t;
                    u3 = t.value, c3 < 2 && (c3 = 0);
                  } else 1 === c3 && (t = i3.return) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                  i3 = e;
                } else if ((t = (y = G.n < 0) ? u3 : r3.call(n3, G)) !== a) break;
              } catch (t2) {
                i3 = e, c3 = 1, u3 = t2;
              } finally {
                f2 = 1;
              }
            }
            return { value: t, done: y };
          };
        })(r2, o2, i2), true), u2;
      }
      var a = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t = Object.getPrototypeOf;
      var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function() {
        return this;
      }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
      function f(e2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function() {
        return this;
      }), _regeneratorDefine2(u, "toString", function() {
        return "[object Generator]";
      }), (_regenerator = function _regenerator2() {
        return { w: i, m: f };
      })();
    }
    function _regeneratorDefine2(e, r, n, t) {
      var i = Object.defineProperty;
      try {
        i({}, "", {});
      } catch (e2) {
        i = 0;
      }
      _regeneratorDefine2 = function _regeneratorDefine(e2, r2, n2, t2) {
        function o(r3, n3) {
          _regeneratorDefine2(e2, r3, function(e3) {
            return this._invoke(r3, n3, e3);
          });
        }
        r2 ? i ? i(e2, r2, { value: n2, enumerable: !t2, configurable: !t2, writable: !t2 }) : e2[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
      }, _regeneratorDefine2(e, r, n, t);
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SentTransaction = exports.SentTransaction = (function() {
      function SentTransaction2(assembled) {
        var _this = this;
        _classCallCheck(this, SentTransaction2);
        _defineProperty(this, "send", (function() {
          var _ref = _asyncToGenerator(_regenerator().m(function _callee2(watcher) {
            var _this$assembled$optio;
            var hash, timeoutInSeconds;
            return _regenerator().w(function(_context2) {
              while (1) switch (_context2.n) {
                case 0:
                  _context2.n = 1;
                  return _this.server.sendTransaction(_this.assembled.signed);
                case 1:
                  _this.sendTransactionResponse = _context2.v;
                  if (!(_this.sendTransactionResponse.status !== "PENDING")) {
                    _context2.n = 2;
                    break;
                  }
                  throw new SentTransaction2.Errors.SendFailed("Sending the transaction to the network failed!\n".concat(JSON.stringify(_this.sendTransactionResponse, null, 2)));
                case 2:
                  if (watcher !== null && watcher !== void 0 && watcher.onSubmitted) watcher.onSubmitted(_this.sendTransactionResponse);
                  hash = _this.sendTransactionResponse.hash;
                  timeoutInSeconds = (_this$assembled$optio = _this.assembled.options.timeoutInSeconds) !== null && _this$assembled$optio !== void 0 ? _this$assembled$optio : _types.DEFAULT_TIMEOUT;
                  _context2.n = 3;
                  return (0, _utils.withExponentialBackoff)(_asyncToGenerator(_regenerator().m(function _callee() {
                    var tx;
                    return _regenerator().w(function(_context) {
                      while (1) switch (_context.n) {
                        case 0:
                          _context.n = 1;
                          return _this.server.getTransaction(hash);
                        case 1:
                          tx = _context.v;
                          if (watcher !== null && watcher !== void 0 && watcher.onProgress) watcher.onProgress(tx);
                          return _context.a(2, tx);
                      }
                    }, _callee);
                  })), function(resp) {
                    return resp.status === _api.Api.GetTransactionStatus.NOT_FOUND;
                  }, timeoutInSeconds);
                case 3:
                  _this.getTransactionResponseAll = _context2.v;
                  _this.getTransactionResponse = _this.getTransactionResponseAll[_this.getTransactionResponseAll.length - 1];
                  if (!(_this.getTransactionResponse.status === _api.Api.GetTransactionStatus.NOT_FOUND)) {
                    _context2.n = 4;
                    break;
                  }
                  throw new SentTransaction2.Errors.TransactionStillPending("Waited ".concat(timeoutInSeconds, " seconds for transaction to complete, but it did not. ") + "Returning anyway. Check the transaction status manually. " + "Sent transaction: ".concat(JSON.stringify(_this.sendTransactionResponse, null, 2), "\n") + "All attempts to get the result: ".concat(JSON.stringify(_this.getTransactionResponseAll, null, 2)));
                case 4:
                  return _context2.a(2, _this);
              }
            }, _callee2);
          }));
          return function(_x) {
            return _ref.apply(this, arguments);
          };
        })());
        this.assembled = assembled;
        var _this$assembled$optio2 = this.assembled.options, server = _this$assembled$optio2.server, allowHttp = _this$assembled$optio2.allowHttp, headers = _this$assembled$optio2.headers, rpcUrl = _this$assembled$optio2.rpcUrl;
        this.server = server !== null && server !== void 0 ? server : new _rpc.Server(rpcUrl, {
          allowHttp,
          headers
        });
      }
      return _createClass(SentTransaction2, [{
        key: "result",
        get: function get() {
          if ("getTransactionResponse" in this && this.getTransactionResponse) {
            if ("returnValue" in this.getTransactionResponse) {
              return this.assembled.options.parseResultXdr(this.getTransactionResponse.returnValue);
            }
            throw new Error("Transaction failed! Cannot parse result.");
          }
          if (this.sendTransactionResponse) {
            var _this$sendTransaction;
            var errorResult = (_this$sendTransaction = this.sendTransactionResponse.errorResult) === null || _this$sendTransaction === void 0 ? void 0 : _this$sendTransaction.result();
            if (errorResult) {
              throw new SentTransaction2.Errors.SendFailed("Transaction simulation looked correct, but attempting to send the transaction failed. Check `simulation` and `sendTransactionResponseAll` to troubleshoot. Decoded `sendTransactionResponse.errorResultXdr`: ".concat(errorResult));
            }
            throw new SentTransaction2.Errors.SendResultOnly("Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with `getTransaction(sendTransactionResponse.hash)`");
          }
          throw new Error("Sending transaction failed: ".concat(JSON.stringify(this.assembled.signed)));
        }
      }]);
    })();
    _SentTransaction = SentTransaction;
    _defineProperty(SentTransaction, "Errors", {
      SendFailed: (function(_Error) {
        function SendFailedError() {
          _classCallCheck(this, SendFailedError);
          return _callSuper(this, SendFailedError, arguments);
        }
        _inherits(SendFailedError, _Error);
        return _createClass(SendFailedError);
      })(_wrapNativeSuper(Error)),
      SendResultOnly: (function(_Error2) {
        function SendResultOnlyError() {
          _classCallCheck(this, SendResultOnlyError);
          return _callSuper(this, SendResultOnlyError, arguments);
        }
        _inherits(SendResultOnlyError, _Error2);
        return _createClass(SendResultOnlyError);
      })(_wrapNativeSuper(Error)),
      TransactionStillPending: (function(_Error3) {
        function TransactionStillPendingError() {
          _classCallCheck(this, TransactionStillPendingError);
          return _callSuper(this, TransactionStillPendingError, arguments);
        }
        _inherits(TransactionStillPendingError, _Error3);
        return _createClass(TransactionStillPendingError);
      })(_wrapNativeSuper(Error))
    });
    _defineProperty(SentTransaction, "init", (function() {
      var _ref3 = _asyncToGenerator(_regenerator().m(function _callee3(assembled, watcher) {
        var tx, sent;
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              tx = new _SentTransaction(assembled);
              _context3.n = 1;
              return tx.send(watcher);
            case 1:
              sent = _context3.v;
              return _context3.a(2, sent);
          }
        }, _callee3);
      }));
      return function(_x2, _x3) {
        return _ref3.apply(this, arguments);
      };
    })());
    var Watcher = exports.Watcher = _createClass(function Watcher2() {
      _classCallCheck(this, Watcher2);
    });
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/errors.js
var require_errors = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/errors.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UserRejectedError = exports.SimulationFailedError = exports.RestoreFailureError = exports.NotYetSimulatedError = exports.NoUnsignedNonInvokerAuthEntriesError = exports.NoSignerError = exports.NoSignatureNeededError = exports.NeedsMoreSignaturesError = exports.InvalidClientRequestError = exports.InternalWalletError = exports.FakeAccountError = exports.ExternalServiceError = exports.ExpiredStateError = void 0;
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !_isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return _construct(t2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
      }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    var ExpiredStateError = exports.ExpiredStateError = (function(_Error) {
      function ExpiredStateError2() {
        _classCallCheck(this, ExpiredStateError2);
        return _callSuper(this, ExpiredStateError2, arguments);
      }
      _inherits(ExpiredStateError2, _Error);
      return _createClass(ExpiredStateError2);
    })(_wrapNativeSuper(Error));
    var RestoreFailureError = exports.RestoreFailureError = (function(_Error2) {
      function RestoreFailureError2() {
        _classCallCheck(this, RestoreFailureError2);
        return _callSuper(this, RestoreFailureError2, arguments);
      }
      _inherits(RestoreFailureError2, _Error2);
      return _createClass(RestoreFailureError2);
    })(_wrapNativeSuper(Error));
    var NeedsMoreSignaturesError = exports.NeedsMoreSignaturesError = (function(_Error3) {
      function NeedsMoreSignaturesError2() {
        _classCallCheck(this, NeedsMoreSignaturesError2);
        return _callSuper(this, NeedsMoreSignaturesError2, arguments);
      }
      _inherits(NeedsMoreSignaturesError2, _Error3);
      return _createClass(NeedsMoreSignaturesError2);
    })(_wrapNativeSuper(Error));
    var NoSignatureNeededError = exports.NoSignatureNeededError = (function(_Error4) {
      function NoSignatureNeededError2() {
        _classCallCheck(this, NoSignatureNeededError2);
        return _callSuper(this, NoSignatureNeededError2, arguments);
      }
      _inherits(NoSignatureNeededError2, _Error4);
      return _createClass(NoSignatureNeededError2);
    })(_wrapNativeSuper(Error));
    var NoUnsignedNonInvokerAuthEntriesError = exports.NoUnsignedNonInvokerAuthEntriesError = (function(_Error5) {
      function NoUnsignedNonInvokerAuthEntriesError2() {
        _classCallCheck(this, NoUnsignedNonInvokerAuthEntriesError2);
        return _callSuper(this, NoUnsignedNonInvokerAuthEntriesError2, arguments);
      }
      _inherits(NoUnsignedNonInvokerAuthEntriesError2, _Error5);
      return _createClass(NoUnsignedNonInvokerAuthEntriesError2);
    })(_wrapNativeSuper(Error));
    var NoSignerError = exports.NoSignerError = (function(_Error6) {
      function NoSignerError2() {
        _classCallCheck(this, NoSignerError2);
        return _callSuper(this, NoSignerError2, arguments);
      }
      _inherits(NoSignerError2, _Error6);
      return _createClass(NoSignerError2);
    })(_wrapNativeSuper(Error));
    var NotYetSimulatedError = exports.NotYetSimulatedError = (function(_Error7) {
      function NotYetSimulatedError2() {
        _classCallCheck(this, NotYetSimulatedError2);
        return _callSuper(this, NotYetSimulatedError2, arguments);
      }
      _inherits(NotYetSimulatedError2, _Error7);
      return _createClass(NotYetSimulatedError2);
    })(_wrapNativeSuper(Error));
    var FakeAccountError = exports.FakeAccountError = (function(_Error8) {
      function FakeAccountError2() {
        _classCallCheck(this, FakeAccountError2);
        return _callSuper(this, FakeAccountError2, arguments);
      }
      _inherits(FakeAccountError2, _Error8);
      return _createClass(FakeAccountError2);
    })(_wrapNativeSuper(Error));
    var SimulationFailedError = exports.SimulationFailedError = (function(_Error9) {
      function SimulationFailedError2() {
        _classCallCheck(this, SimulationFailedError2);
        return _callSuper(this, SimulationFailedError2, arguments);
      }
      _inherits(SimulationFailedError2, _Error9);
      return _createClass(SimulationFailedError2);
    })(_wrapNativeSuper(Error));
    var InternalWalletError = exports.InternalWalletError = (function(_Error0) {
      function InternalWalletError2() {
        _classCallCheck(this, InternalWalletError2);
        return _callSuper(this, InternalWalletError2, arguments);
      }
      _inherits(InternalWalletError2, _Error0);
      return _createClass(InternalWalletError2);
    })(_wrapNativeSuper(Error));
    var ExternalServiceError = exports.ExternalServiceError = (function(_Error1) {
      function ExternalServiceError2() {
        _classCallCheck(this, ExternalServiceError2);
        return _callSuper(this, ExternalServiceError2, arguments);
      }
      _inherits(ExternalServiceError2, _Error1);
      return _createClass(ExternalServiceError2);
    })(_wrapNativeSuper(Error));
    var InvalidClientRequestError = exports.InvalidClientRequestError = (function(_Error10) {
      function InvalidClientRequestError2() {
        _classCallCheck(this, InvalidClientRequestError2);
        return _callSuper(this, InvalidClientRequestError2, arguments);
      }
      _inherits(InvalidClientRequestError2, _Error10);
      return _createClass(InvalidClientRequestError2);
    })(_wrapNativeSuper(Error));
    var UserRejectedError = exports.UserRejectedError = (function(_Error11) {
      function UserRejectedError2() {
        _classCallCheck(this, UserRejectedError2);
        return _callSuper(this, UserRejectedError2, arguments);
      }
      _inherits(UserRejectedError2, _Error11);
      return _createClass(UserRejectedError2);
    })(_wrapNativeSuper(Error));
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/assembled_transaction.js
var require_assembled_transaction = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/assembled_transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AssembledTransaction = void 0;
    var _stellarBase = require_stellar_base_min();
    var _rpc = require_rpc();
    var _api = require_api();
    var _transaction = require_transaction();
    var _rust_result = require_rust_result();
    var _utils = require_utils();
    var _types = require_types();
    var _sent_transaction = require_sent_transaction();
    var _errors = require_errors();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _regeneratorValues(e) {
      if (null != e) {
        var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0;
        if (t) return t.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) return { next: function next() {
          return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
        } };
      }
      throw new TypeError(_typeof(e) + " is not iterable");
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _createForOfIteratorHelper(r, e) {
      var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (!t) {
        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
          t && (r = t);
          var _n = 0, F = function F2() {
          };
          return { s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return { s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      } };
    }
    function _regenerator() {
      var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
      function i(r2, n2, o2, i2) {
        var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
        return _regeneratorDefine2(u2, "_invoke", (function(r3, n3, o3) {
          var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d2(t2, r4) {
            return i3 = t2, c3 = 0, u3 = e, G.n = r4, a;
          } };
          function d(r4, n4) {
            for (c3 = r4, u3 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
              var o4, i4 = p[t], d2 = G.p, l = i4[2];
              r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c3 = 0));
            }
            if (o4 || r4 > 1) return a;
            throw y = true, n4;
          }
          return function(o4, p2, l) {
            if (f2 > 1) throw TypeError("Generator is already running");
            for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
              i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
              try {
                if (f2 = 2, i3) {
                  if (c3 || (o4 = "next"), t = i3[o4]) {
                    if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                    if (!t.done) return t;
                    u3 = t.value, c3 < 2 && (c3 = 0);
                  } else 1 === c3 && (t = i3.return) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                  i3 = e;
                } else if ((t = (y = G.n < 0) ? u3 : r3.call(n3, G)) !== a) break;
              } catch (t2) {
                i3 = e, c3 = 1, u3 = t2;
              } finally {
                f2 = 1;
              }
            }
            return { value: t, done: y };
          };
        })(r2, o2, i2), true), u2;
      }
      var a = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t = Object.getPrototypeOf;
      var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function() {
        return this;
      }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
      function f(e2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function() {
        return this;
      }), _regeneratorDefine2(u, "toString", function() {
        return "[object Generator]";
      }), (_regenerator = function _regenerator2() {
        return { w: i, m: f };
      })();
    }
    function _regeneratorDefine2(e, r, n, t) {
      var i = Object.defineProperty;
      try {
        i({}, "", {});
      } catch (e2) {
        i = 0;
      }
      _regeneratorDefine2 = function _regeneratorDefine(e2, r2, n2, t2) {
        function o(r3, n3) {
          _regeneratorDefine2(e2, r3, function(e3) {
            return this._invoke(r3, n3, e3);
          });
        }
        r2 ? i ? i(e2, r2, { value: n2, enumerable: !t2, configurable: !t2, writable: !t2 }) : e2[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
      }, _regeneratorDefine2(e, r, n, t);
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var AssembledTransaction = exports.AssembledTransaction = (function() {
      function AssembledTransaction2(options) {
        var _this = this, _this$options$simulat;
        _classCallCheck(this, AssembledTransaction2);
        _defineProperty(this, "simulate", _asyncToGenerator(_regenerator().m(function _callee() {
          var _ref2, restore, account, result, _this$options$fee, _this$options$args, _this$options$timeout, contract, _args = arguments;
          return _regenerator().w(function(_context) {
            while (1) switch (_context.n) {
              case 0:
                _ref2 = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {}, restore = _ref2.restore;
                if (_this.built) {
                  _context.n = 2;
                  break;
                }
                if (_this.raw) {
                  _context.n = 1;
                  break;
                }
                throw new Error("Transaction has not yet been assembled; call `AssembledTransaction.build` first.");
              case 1:
                _this.built = _this.raw.build();
              case 2:
                restore = restore !== null && restore !== void 0 ? restore : _this.options.restore;
                delete _this.simulationResult;
                delete _this.simulationTransactionData;
                _context.n = 3;
                return _this.server.simulateTransaction(_this.built);
              case 3:
                _this.simulation = _context.v;
                if (!(restore && _api.Api.isSimulationRestore(_this.simulation))) {
                  _context.n = 8;
                  break;
                }
                _context.n = 4;
                return (0, _utils.getAccount)(_this.options, _this.server);
              case 4:
                account = _context.v;
                _context.n = 5;
                return _this.restoreFootprint(_this.simulation.restorePreamble, account);
              case 5:
                result = _context.v;
                if (!(result.status === _api.Api.GetTransactionStatus.SUCCESS)) {
                  _context.n = 7;
                  break;
                }
                contract = new _stellarBase.Contract(_this.options.contractId);
                _this.raw = new _stellarBase.TransactionBuilder(account, {
                  fee: (_this$options$fee = _this.options.fee) !== null && _this$options$fee !== void 0 ? _this$options$fee : _stellarBase.BASE_FEE,
                  networkPassphrase: _this.options.networkPassphrase
                }).addOperation(contract.call.apply(contract, [_this.options.method].concat(_toConsumableArray((_this$options$args = _this.options.args) !== null && _this$options$args !== void 0 ? _this$options$args : [])))).setTimeout((_this$options$timeout = _this.options.timeoutInSeconds) !== null && _this$options$timeout !== void 0 ? _this$options$timeout : _types.DEFAULT_TIMEOUT);
                _context.n = 6;
                return _this.simulate();
              case 6:
                return _context.a(2, _this);
              case 7:
                throw new AssembledTransaction2.Errors.RestorationFailure("Automatic restore failed! You set 'restore: true' but the attempted restore did not work. Result:\n".concat(JSON.stringify(result)));
              case 8:
                if (_api.Api.isSimulationSuccess(_this.simulation)) {
                  _this.built = (0, _transaction.assembleTransaction)(_this.built, _this.simulation).build();
                }
                return _context.a(2, _this);
            }
          }, _callee);
        })));
        _defineProperty(this, "sign", _asyncToGenerator(_regenerator().m(function _callee2() {
          var _this$options$timeout2;
          var _ref4, _ref4$force, force, _ref4$signTransaction, signTransaction, sigsNeeded, timeoutInSeconds, signOpts, _yield$signTransactio, signature, error, _args2 = arguments;
          return _regenerator().w(function(_context2) {
            while (1) switch (_context2.n) {
              case 0:
                _ref4 = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : {}, _ref4$force = _ref4.force, force = _ref4$force === void 0 ? false : _ref4$force, _ref4$signTransaction = _ref4.signTransaction, signTransaction = _ref4$signTransaction === void 0 ? _this.options.signTransaction : _ref4$signTransaction;
                if (_this.built) {
                  _context2.n = 1;
                  break;
                }
                throw new Error("Transaction has not yet been simulated");
              case 1:
                if (!(!force && _this.isReadCall)) {
                  _context2.n = 2;
                  break;
                }
                throw new AssembledTransaction2.Errors.NoSignatureNeeded("This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.");
              case 2:
                if (signTransaction) {
                  _context2.n = 3;
                  break;
                }
                throw new AssembledTransaction2.Errors.NoSigner("You must provide a signTransaction function, either when calling `signAndSend` or when initializing your Client");
              case 3:
                if (_this.options.publicKey) {
                  _context2.n = 4;
                  break;
                }
                throw new AssembledTransaction2.Errors.FakeAccount("This transaction was constructed using a default account. Provide a valid publicKey in the AssembledTransactionOptions.");
              case 4:
                sigsNeeded = _this.needsNonInvokerSigningBy().filter(function(id) {
                  return !id.startsWith("C");
                });
                if (!sigsNeeded.length) {
                  _context2.n = 5;
                  break;
                }
                throw new AssembledTransaction2.Errors.NeedsMoreSignatures("Transaction requires signatures from ".concat(sigsNeeded, ". ") + "See `needsNonInvokerSigningBy` for details.");
              case 5:
                timeoutInSeconds = (_this$options$timeout2 = _this.options.timeoutInSeconds) !== null && _this$options$timeout2 !== void 0 ? _this$options$timeout2 : _types.DEFAULT_TIMEOUT;
                _this.built = _stellarBase.TransactionBuilder.cloneFrom(_this.built, {
                  fee: _this.built.fee,
                  timebounds: void 0,
                  sorobanData: _this.simulationData.transactionData
                }).setTimeout(timeoutInSeconds).build();
                signOpts = {
                  networkPassphrase: _this.options.networkPassphrase
                };
                if (_this.options.address) signOpts.address = _this.options.address;
                if (_this.options.submit !== void 0) signOpts.submit = _this.options.submit;
                if (_this.options.submitUrl) signOpts.submitUrl = _this.options.submitUrl;
                _context2.n = 6;
                return signTransaction(_this.built.toXDR(), signOpts);
              case 6:
                _yield$signTransactio = _context2.v;
                signature = _yield$signTransactio.signedTxXdr;
                error = _yield$signTransactio.error;
                _this.handleWalletError(error);
                _this.signed = _stellarBase.TransactionBuilder.fromXDR(signature, _this.options.networkPassphrase);
              case 7:
                return _context2.a(2);
            }
          }, _callee2);
        })));
        _defineProperty(this, "signAndSend", _asyncToGenerator(_regenerator().m(function _callee3() {
          var _ref6, _ref6$force, force, _ref6$signTransaction, signTransaction, watcher, originalSubmit, _args3 = arguments;
          return _regenerator().w(function(_context3) {
            while (1) switch (_context3.p = _context3.n) {
              case 0:
                _ref6 = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : {}, _ref6$force = _ref6.force, force = _ref6$force === void 0 ? false : _ref6$force, _ref6$signTransaction = _ref6.signTransaction, signTransaction = _ref6$signTransaction === void 0 ? _this.options.signTransaction : _ref6$signTransaction, watcher = _ref6.watcher;
                if (_this.signed) {
                  _context3.n = 3;
                  break;
                }
                originalSubmit = _this.options.submit;
                if (_this.options.submit) {
                  _this.options.submit = false;
                }
                _context3.p = 1;
                _context3.n = 2;
                return _this.sign({
                  force,
                  signTransaction
                });
              case 2:
                _context3.p = 2;
                _this.options.submit = originalSubmit;
                return _context3.f(2);
              case 3:
                return _context3.a(2, _this.send(watcher));
            }
          }, _callee3, null, [[1, , 2, 3]]);
        })));
        _defineProperty(this, "needsNonInvokerSigningBy", function() {
          var _rawInvokeHostFunctio;
          var _ref7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref7$includeAlreadyS = _ref7.includeAlreadySigned, includeAlreadySigned = _ref7$includeAlreadyS === void 0 ? false : _ref7$includeAlreadyS;
          if (!_this.built) {
            throw new Error("Transaction has not yet been simulated");
          }
          if (!("operations" in _this.built)) {
            throw new Error("Unexpected Transaction type; no operations: ".concat(JSON.stringify(_this.built)));
          }
          var rawInvokeHostFunctionOp = _this.built.operations[0];
          return _toConsumableArray(new Set(((_rawInvokeHostFunctio = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio !== void 0 ? _rawInvokeHostFunctio : []).filter(function(entry) {
            return entry.credentials().switch() === _stellarBase.xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (includeAlreadySigned || entry.credentials().address().signature().switch().name === "scvVoid");
          }).map(function(entry) {
            return _stellarBase.Address.fromScAddress(entry.credentials().address().address()).toString();
          })));
        });
        _defineProperty(this, "signAuthEntries", _asyncToGenerator(_regenerator().m(function _callee6() {
          var _rawInvokeHostFunctio2;
          var _ref9, _ref9$expiration, expiration, _ref9$signAuthEntry, signAuthEntry, _ref9$address, address, _ref9$authorizeEntry, authorizeEntry, needsNonInvokerSigningBy, rawInvokeHostFunctionOp, authEntries, _iterator, _step, _loop, _ret, _args7 = arguments, _t5;
          return _regenerator().w(function(_context7) {
            while (1) switch (_context7.p = _context7.n) {
              case 0:
                _ref9 = _args7.length > 0 && _args7[0] !== void 0 ? _args7[0] : {}, _ref9$expiration = _ref9.expiration, expiration = _ref9$expiration === void 0 ? _asyncToGenerator(_regenerator().m(function _callee4() {
                  var _t;
                  return _regenerator().w(function(_context4) {
                    while (1) switch (_context4.n) {
                      case 0:
                        _context4.n = 1;
                        return _this.server.getLatestLedger();
                      case 1:
                        _t = _context4.v.sequence;
                        return _context4.a(2, _t + 100);
                    }
                  }, _callee4);
                }))() : _ref9$expiration, _ref9$signAuthEntry = _ref9.signAuthEntry, signAuthEntry = _ref9$signAuthEntry === void 0 ? _this.options.signAuthEntry : _ref9$signAuthEntry, _ref9$address = _ref9.address, address = _ref9$address === void 0 ? _this.options.publicKey : _ref9$address, _ref9$authorizeEntry = _ref9.authorizeEntry, authorizeEntry = _ref9$authorizeEntry === void 0 ? _stellarBase.authorizeEntry : _ref9$authorizeEntry;
                if (_this.built) {
                  _context7.n = 1;
                  break;
                }
                throw new Error("Transaction has not yet been assembled or simulated");
              case 1:
                if (!(authorizeEntry === _stellarBase.authorizeEntry)) {
                  _context7.n = 4;
                  break;
                }
                needsNonInvokerSigningBy = _this.needsNonInvokerSigningBy();
                if (!(needsNonInvokerSigningBy.length === 0)) {
                  _context7.n = 2;
                  break;
                }
                throw new AssembledTransaction2.Errors.NoUnsignedNonInvokerAuthEntries("No unsigned non-invoker auth entries; maybe you already signed?");
              case 2:
                if (!(needsNonInvokerSigningBy.indexOf(address !== null && address !== void 0 ? address : "") === -1)) {
                  _context7.n = 3;
                  break;
                }
                throw new AssembledTransaction2.Errors.NoSignatureNeeded('No auth entries for public key "'.concat(address, '"'));
              case 3:
                if (signAuthEntry) {
                  _context7.n = 4;
                  break;
                }
                throw new AssembledTransaction2.Errors.NoSigner("You must provide `signAuthEntry` or a custom `authorizeEntry`");
              case 4:
                rawInvokeHostFunctionOp = _this.built.operations[0];
                authEntries = (_rawInvokeHostFunctio2 = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio2 !== void 0 ? _rawInvokeHostFunctio2 : [];
                _iterator = _createForOfIteratorHelper(authEntries.entries());
                _context7.p = 5;
                _loop = _regenerator().m(function _loop2() {
                  var _step$value, i, entry, credentials, authEntryAddress, sign, _t2, _t3, _t4;
                  return _regenerator().w(function(_context6) {
                    while (1) switch (_context6.n) {
                      case 0:
                        _step$value = _slicedToArray(_step.value, 2), i = _step$value[0], entry = _step$value[1];
                        credentials = _stellarBase.xdr.SorobanCredentials.fromXDR(entry.credentials().toXDR());
                        if (!(credentials.switch() !== _stellarBase.xdr.SorobanCredentialsType.sorobanCredentialsAddress())) {
                          _context6.n = 1;
                          break;
                        }
                        return _context6.a(2, 0);
                      case 1:
                        authEntryAddress = _stellarBase.Address.fromScAddress(credentials.address().address()).toString();
                        if (!(authEntryAddress !== address)) {
                          _context6.n = 2;
                          break;
                        }
                        return _context6.a(2, 0);
                      case 2:
                        sign = signAuthEntry !== null && signAuthEntry !== void 0 ? signAuthEntry : Promise.resolve;
                        _t2 = authorizeEntry;
                        _t3 = entry;
                        _t4 = (function() {
                          var _ref1 = _asyncToGenerator(_regenerator().m(function _callee5(preimage) {
                            var _yield$sign, signedAuthEntry, error;
                            return _regenerator().w(function(_context5) {
                              while (1) switch (_context5.n) {
                                case 0:
                                  _context5.n = 1;
                                  return sign(preimage.toXDR("base64"), {
                                    address
                                  });
                                case 1:
                                  _yield$sign = _context5.v;
                                  signedAuthEntry = _yield$sign.signedAuthEntry;
                                  error = _yield$sign.error;
                                  _this.handleWalletError(error);
                                  return _context5.a(2, Buffer.from(signedAuthEntry, "base64"));
                              }
                            }, _callee5);
                          }));
                          return function(_x) {
                            return _ref1.apply(this, arguments);
                          };
                        })();
                        _context6.n = 3;
                        return expiration;
                      case 3:
                        _context6.n = 4;
                        return _t2(_t3, _t4, _context6.v, _this.options.networkPassphrase);
                      case 4:
                        authEntries[i] = _context6.v;
                      case 5:
                        return _context6.a(2);
                    }
                  }, _loop2);
                });
                _iterator.s();
              case 6:
                if ((_step = _iterator.n()).done) {
                  _context7.n = 9;
                  break;
                }
                return _context7.d(_regeneratorValues(_loop()), 7);
              case 7:
                _ret = _context7.v;
                if (!(_ret === 0)) {
                  _context7.n = 8;
                  break;
                }
                return _context7.a(3, 8);
              case 8:
                _context7.n = 6;
                break;
              case 9:
                _context7.n = 11;
                break;
              case 10:
                _context7.p = 10;
                _t5 = _context7.v;
                _iterator.e(_t5);
              case 11:
                _context7.p = 11;
                _iterator.f();
                return _context7.f(11);
              case 12:
                return _context7.a(2);
            }
          }, _callee6, null, [[5, 10, 11, 12]]);
        })));
        this.options = options;
        this.options.simulate = (_this$options$simulat = this.options.simulate) !== null && _this$options$simulat !== void 0 ? _this$options$simulat : true;
        var _this$options = this.options, server = _this$options.server, allowHttp = _this$options.allowHttp, headers = _this$options.headers, rpcUrl = _this$options.rpcUrl;
        this.server = server !== null && server !== void 0 ? server : new _rpc.Server(rpcUrl, {
          allowHttp,
          headers
        });
      }
      return _createClass(AssembledTransaction2, [{
        key: "toJSON",
        value: function toJSON() {
          var _this$built;
          return JSON.stringify({
            method: this.options.method,
            tx: (_this$built = this.built) === null || _this$built === void 0 ? void 0 : _this$built.toXDR(),
            simulationResult: {
              auth: this.simulationData.result.auth.map(function(a) {
                return a.toXDR("base64");
              }),
              retval: this.simulationData.result.retval.toXDR("base64")
            },
            simulationTransactionData: this.simulationData.transactionData.toXDR("base64")
          });
        }
      }, {
        key: "toXDR",
        value: function toXDR() {
          var _this$built2;
          if (!this.built) throw new Error("Transaction has not yet been simulated; call `AssembledTransaction.simulate` first.");
          return (_this$built2 = this.built) === null || _this$built2 === void 0 ? void 0 : _this$built2.toEnvelope().toXDR("base64");
        }
      }, {
        key: "handleWalletError",
        value: function handleWalletError(error) {
          if (!error) return;
          var message = error.message, code = error.code;
          var fullMessage = "".concat(message).concat(error.ext ? " (".concat(error.ext.join(", "), ")") : "");
          switch (code) {
            case -1:
              throw new AssembledTransaction2.Errors.InternalWalletError(fullMessage);
            case -2:
              throw new AssembledTransaction2.Errors.ExternalServiceError(fullMessage);
            case -3:
              throw new AssembledTransaction2.Errors.InvalidClientRequest(fullMessage);
            case -4:
              throw new AssembledTransaction2.Errors.UserRejected(fullMessage);
            default:
              throw new Error("Unhandled error: ".concat(fullMessage));
          }
        }
      }, {
        key: "simulationData",
        get: function get() {
          var _simulation$result;
          if (this.simulationResult && this.simulationTransactionData) {
            return {
              result: this.simulationResult,
              transactionData: this.simulationTransactionData
            };
          }
          var simulation = this.simulation;
          if (!simulation) {
            throw new AssembledTransaction2.Errors.NotYetSimulated("Transaction has not yet been simulated");
          }
          if (_api.Api.isSimulationError(simulation)) {
            throw new AssembledTransaction2.Errors.SimulationFailed('Transaction simulation failed: "'.concat(simulation.error, '"'));
          }
          if (_api.Api.isSimulationRestore(simulation)) {
            throw new AssembledTransaction2.Errors.ExpiredState("You need to restore some contract state before you can invoke this method.\nYou can set `restore` to true in the method options in order to automatically restore the contract state when needed.");
          }
          this.simulationResult = (_simulation$result = simulation.result) !== null && _simulation$result !== void 0 ? _simulation$result : {
            auth: [],
            retval: _stellarBase.xdr.ScVal.scvVoid()
          };
          this.simulationTransactionData = simulation.transactionData.build();
          return {
            result: this.simulationResult,
            transactionData: this.simulationTransactionData
          };
        }
      }, {
        key: "result",
        get: function get() {
          try {
            if (!this.simulationData.result) {
              throw new Error("No simulation result!");
            }
            return this.options.parseResultXdr(this.simulationData.result.retval);
          } catch (e) {
            if (!(0, _utils.implementsToString)(e)) throw e;
            var err = this.parseError(e.toString());
            if (err) return err;
            throw e;
          }
        }
      }, {
        key: "parseError",
        value: function parseError(errorMessage) {
          if (!this.options.errorTypes) return void 0;
          var match = errorMessage.match(_utils.contractErrorPattern);
          if (!match) return void 0;
          var i = parseInt(match[1], 10);
          var err = this.options.errorTypes[i];
          if (!err) return void 0;
          return new _rust_result.Err(err);
        }
      }, {
        key: "send",
        value: (function() {
          var _send = _asyncToGenerator(_regenerator().m(function _callee7(watcher) {
            var sent;
            return _regenerator().w(function(_context8) {
              while (1) switch (_context8.n) {
                case 0:
                  if (this.signed) {
                    _context8.n = 1;
                    break;
                  }
                  throw new Error("The transaction has not yet been signed. Run `sign` first, or use `signAndSend` instead.");
                case 1:
                  _context8.n = 2;
                  return _sent_transaction.SentTransaction.init(this, watcher);
                case 2:
                  sent = _context8.v;
                  return _context8.a(2, sent);
              }
            }, _callee7, this);
          }));
          function send(_x2) {
            return _send.apply(this, arguments);
          }
          return send;
        })()
      }, {
        key: "isReadCall",
        get: function get() {
          var authsCount = this.simulationData.result.auth.length;
          var writeLength = this.simulationData.transactionData.resources().footprint().readWrite().length;
          return authsCount === 0 && writeLength === 0;
        }
      }, {
        key: "restoreFootprint",
        value: (function() {
          var _restoreFootprint = _asyncToGenerator(_regenerator().m(function _callee8(restorePreamble, account) {
            var restoreTx, sentTransaction, _t6;
            return _regenerator().w(function(_context9) {
              while (1) switch (_context9.n) {
                case 0:
                  if (this.options.signTransaction) {
                    _context9.n = 1;
                    break;
                  }
                  throw new Error("For automatic restore to work you must provide a signTransaction function when initializing your Client");
                case 1:
                  if (!(account !== null && account !== void 0)) {
                    _context9.n = 2;
                    break;
                  }
                  _t6 = account;
                  _context9.n = 4;
                  break;
                case 2:
                  _context9.n = 3;
                  return (0, _utils.getAccount)(this.options, this.server);
                case 3:
                  _t6 = _context9.v;
                case 4:
                  account = _t6;
                  _context9.n = 5;
                  return AssembledTransaction2.buildFootprintRestoreTransaction(_objectSpread({}, this.options), restorePreamble.transactionData, account, restorePreamble.minResourceFee);
                case 5:
                  restoreTx = _context9.v;
                  _context9.n = 6;
                  return restoreTx.signAndSend();
                case 6:
                  sentTransaction = _context9.v;
                  if (sentTransaction.getTransactionResponse) {
                    _context9.n = 7;
                    break;
                  }
                  throw new AssembledTransaction2.Errors.RestorationFailure("The attempt at automatic restore failed. \n".concat(JSON.stringify(sentTransaction)));
                case 7:
                  return _context9.a(2, sentTransaction.getTransactionResponse);
              }
            }, _callee8, this);
          }));
          function restoreFootprint(_x3, _x4) {
            return _restoreFootprint.apply(this, arguments);
          }
          return restoreFootprint;
        })()
      }], [{
        key: "fromJSON",
        value: function fromJSON(options, _ref10) {
          var tx = _ref10.tx, simulationResult = _ref10.simulationResult, simulationTransactionData = _ref10.simulationTransactionData;
          var txn = new AssembledTransaction2(options);
          txn.built = _stellarBase.TransactionBuilder.fromXDR(tx, options.networkPassphrase);
          txn.simulationResult = {
            auth: simulationResult.auth.map(function(a) {
              return _stellarBase.xdr.SorobanAuthorizationEntry.fromXDR(a, "base64");
            }),
            retval: _stellarBase.xdr.ScVal.fromXDR(simulationResult.retval, "base64")
          };
          txn.simulationTransactionData = _stellarBase.xdr.SorobanTransactionData.fromXDR(simulationTransactionData, "base64");
          return txn;
        }
      }, {
        key: "fromXDR",
        value: function fromXDR(options, encodedXDR, spec) {
          var _operation$func;
          var envelope = _stellarBase.xdr.TransactionEnvelope.fromXDR(encodedXDR, "base64");
          var built = _stellarBase.TransactionBuilder.fromXDR(envelope, options.networkPassphrase);
          var operation = built.operations[0];
          if (!(operation !== null && operation !== void 0 && (_operation$func = operation.func) !== null && _operation$func !== void 0 && _operation$func.value) || typeof operation.func.value !== "function") {
            throw new Error("Could not extract the method from the transaction envelope.");
          }
          var invokeContractArgs = operation.func.value();
          if (!(invokeContractArgs !== null && invokeContractArgs !== void 0 && invokeContractArgs.functionName)) {
            throw new Error("Could not extract the method name from the transaction envelope.");
          }
          var method = invokeContractArgs.functionName().toString("utf-8");
          var txn = new AssembledTransaction2(_objectSpread(_objectSpread({}, options), {}, {
            method,
            parseResultXdr: function parseResultXdr(result) {
              return spec.funcResToNative(method, result);
            }
          }));
          txn.built = built;
          return txn;
        }
      }, {
        key: "build",
        value: function build(options) {
          var _options$args;
          var contract = new _stellarBase.Contract(options.contractId);
          return AssembledTransaction2.buildWithOp(contract.call.apply(contract, [options.method].concat(_toConsumableArray((_options$args = options.args) !== null && _options$args !== void 0 ? _options$args : []))), options);
        }
      }, {
        key: "buildWithOp",
        value: (function() {
          var _buildWithOp = _asyncToGenerator(_regenerator().m(function _callee9(operation, options) {
            var _options$fee, _options$timeoutInSec;
            var tx, account;
            return _regenerator().w(function(_context0) {
              while (1) switch (_context0.n) {
                case 0:
                  tx = new AssembledTransaction2(options);
                  _context0.n = 1;
                  return (0, _utils.getAccount)(options, tx.server);
                case 1:
                  account = _context0.v;
                  tx.raw = new _stellarBase.TransactionBuilder(account, {
                    fee: (_options$fee = options.fee) !== null && _options$fee !== void 0 ? _options$fee : _stellarBase.BASE_FEE,
                    networkPassphrase: options.networkPassphrase
                  }).setTimeout((_options$timeoutInSec = options.timeoutInSeconds) !== null && _options$timeoutInSec !== void 0 ? _options$timeoutInSec : _types.DEFAULT_TIMEOUT).addOperation(operation);
                  if (!options.simulate) {
                    _context0.n = 2;
                    break;
                  }
                  _context0.n = 2;
                  return tx.simulate();
                case 2:
                  return _context0.a(2, tx);
              }
            }, _callee9);
          }));
          function buildWithOp(_x5, _x6) {
            return _buildWithOp.apply(this, arguments);
          }
          return buildWithOp;
        })()
      }, {
        key: "buildFootprintRestoreTransaction",
        value: (function() {
          var _buildFootprintRestoreTransaction = _asyncToGenerator(_regenerator().m(function _callee0(options, sorobanData, account, fee) {
            var _options$timeoutInSec2;
            var tx;
            return _regenerator().w(function(_context1) {
              while (1) switch (_context1.n) {
                case 0:
                  tx = new AssembledTransaction2(options);
                  tx.raw = new _stellarBase.TransactionBuilder(account, {
                    fee,
                    networkPassphrase: options.networkPassphrase
                  }).setSorobanData(sorobanData instanceof _stellarBase.SorobanDataBuilder ? sorobanData.build() : sorobanData).addOperation(_stellarBase.Operation.restoreFootprint({})).setTimeout((_options$timeoutInSec2 = options.timeoutInSeconds) !== null && _options$timeoutInSec2 !== void 0 ? _options$timeoutInSec2 : _types.DEFAULT_TIMEOUT);
                  _context1.n = 1;
                  return tx.simulate({
                    restore: false
                  });
                case 1:
                  return _context1.a(2, tx);
              }
            }, _callee0);
          }));
          function buildFootprintRestoreTransaction(_x7, _x8, _x9, _x0) {
            return _buildFootprintRestoreTransaction.apply(this, arguments);
          }
          return buildFootprintRestoreTransaction;
        })()
      }]);
    })();
    _defineProperty(AssembledTransaction, "Errors", {
      ExpiredState: _errors.ExpiredStateError,
      RestorationFailure: _errors.RestoreFailureError,
      NeedsMoreSignatures: _errors.NeedsMoreSignaturesError,
      NoSignatureNeeded: _errors.NoSignatureNeededError,
      NoUnsignedNonInvokerAuthEntries: _errors.NoUnsignedNonInvokerAuthEntriesError,
      NoSigner: _errors.NoSignerError,
      NotYetSimulated: _errors.NotYetSimulatedError,
      FakeAccount: _errors.FakeAccountError,
      SimulationFailed: _errors.SimulationFailedError,
      InternalWalletError: _errors.InternalWalletError,
      ExternalServiceError: _errors.ExternalServiceError,
      InvalidClientRequest: _errors.InvalidClientRequestError,
      UserRejected: _errors.UserRejectedError
    });
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/basic_node_signer.js
var require_basic_node_signer = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/basic_node_signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.basicNodeSigner = void 0;
    var _stellarBase = require_stellar_base_min();
    function _regenerator() {
      var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
      function i(r2, n2, o2, i2) {
        var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
        return _regeneratorDefine2(u2, "_invoke", (function(r3, n3, o3) {
          var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d2(t2, r4) {
            return i3 = t2, c3 = 0, u3 = e, G.n = r4, a;
          } };
          function d(r4, n4) {
            for (c3 = r4, u3 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
              var o4, i4 = p[t], d2 = G.p, l = i4[2];
              r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c3 = 0));
            }
            if (o4 || r4 > 1) return a;
            throw y = true, n4;
          }
          return function(o4, p2, l) {
            if (f2 > 1) throw TypeError("Generator is already running");
            for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
              i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
              try {
                if (f2 = 2, i3) {
                  if (c3 || (o4 = "next"), t = i3[o4]) {
                    if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                    if (!t.done) return t;
                    u3 = t.value, c3 < 2 && (c3 = 0);
                  } else 1 === c3 && (t = i3.return) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                  i3 = e;
                } else if ((t = (y = G.n < 0) ? u3 : r3.call(n3, G)) !== a) break;
              } catch (t2) {
                i3 = e, c3 = 1, u3 = t2;
              } finally {
                f2 = 1;
              }
            }
            return { value: t, done: y };
          };
        })(r2, o2, i2), true), u2;
      }
      var a = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t = Object.getPrototypeOf;
      var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function() {
        return this;
      }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
      function f(e2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function() {
        return this;
      }), _regeneratorDefine2(u, "toString", function() {
        return "[object Generator]";
      }), (_regenerator = function _regenerator2() {
        return { w: i, m: f };
      })();
    }
    function _regeneratorDefine2(e, r, n, t) {
      var i = Object.defineProperty;
      try {
        i({}, "", {});
      } catch (e2) {
        i = 0;
      }
      _regeneratorDefine2 = function _regeneratorDefine(e2, r2, n2, t2) {
        function o(r3, n3) {
          _regeneratorDefine2(e2, r3, function(e3) {
            return this._invoke(r3, n3, e3);
          });
        }
        r2 ? i ? i(e2, r2, { value: n2, enumerable: !t2, configurable: !t2, writable: !t2 }) : e2[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
      }, _regeneratorDefine2(e, r, n, t);
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var basicNodeSigner = exports.basicNodeSigner = function basicNodeSigner2(keypair, networkPassphrase) {
      return {
        signTransaction: (function() {
          var _signTransaction = _asyncToGenerator(_regenerator().m(function _callee(xdr, opts) {
            var t;
            return _regenerator().w(function(_context) {
              while (1) switch (_context.n) {
                case 0:
                  t = _stellarBase.TransactionBuilder.fromXDR(xdr, (opts === null || opts === void 0 ? void 0 : opts.networkPassphrase) || networkPassphrase);
                  t.sign(keypair);
                  return _context.a(2, {
                    signedTxXdr: t.toXDR(),
                    signerAddress: keypair.publicKey()
                  });
              }
            }, _callee);
          }));
          function signTransaction(_x, _x2) {
            return _signTransaction.apply(this, arguments);
          }
          return signTransaction;
        })(),
        signAuthEntry: (function() {
          var _signAuthEntry = _asyncToGenerator(_regenerator().m(function _callee2(authEntry) {
            var signedAuthEntry;
            return _regenerator().w(function(_context2) {
              while (1) switch (_context2.n) {
                case 0:
                  signedAuthEntry = keypair.sign((0, _stellarBase.hash)(Buffer.from(authEntry, "base64"))).toString("base64");
                  return _context2.a(2, {
                    signedAuthEntry,
                    signerAddress: keypair.publicKey()
                  });
              }
            }, _callee2);
          }));
          function signAuthEntry(_x3) {
            return _signAuthEntry.apply(this, arguments);
          }
          return signAuthEntry;
        })()
      };
    };
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/wasm_spec_parser.js
var require_wasm_spec_parser = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/wasm_spec_parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.specFromWasm = specFromWasm;
    var _utils = require_utils();
    function specFromWasm(wasm) {
      var customData = (0, _utils.parseWasmCustomSections)(wasm);
      var xdrSections = customData.get("contractspecv0");
      if (!xdrSections || xdrSections.length === 0) {
        throw new Error("Could not obtain contract spec from wasm");
      }
      return Buffer.from(xdrSections[0]);
    }
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/spec.js
var require_spec = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/spec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Spec = void 0;
    var _stellarBase = require_stellar_base_min();
    var _rust_result = require_rust_result();
    var _utils = require_utils();
    var _wasm_spec_parser = require_wasm_spec_parser();
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function enumToJsonSchema(udt) {
      var description = udt.doc().toString();
      var cases = udt.cases();
      var oneOf = [];
      cases.forEach(function(aCase) {
        var title = aCase.name().toString();
        var desc = aCase.doc().toString();
        oneOf.push({
          description: desc,
          title,
          enum: [aCase.value()],
          type: "number"
        });
      });
      var res = {
        oneOf
      };
      if (description.length > 0) {
        res.description = description;
      }
      return res;
    }
    function isNumeric(field) {
      return /^\d+$/.test(field.name().toString());
    }
    function readObj(args, input) {
      var inputName = input.name().toString();
      var entry = Object.entries(args).find(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), name = _ref2[0];
        return name === inputName;
      });
      if (!entry) {
        throw new Error("Missing field ".concat(inputName));
      }
      return entry[1];
    }
    function findCase(name) {
      return function matches(entry) {
        switch (entry.switch().value) {
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
            var tuple = entry.tupleCase();
            return tuple.name().toString() === name;
          }
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
            var voidCase = entry.voidCase();
            return voidCase.name().toString() === name;
          }
          default:
            return false;
        }
      };
    }
    function stringToScVal(str, ty) {
      switch (ty.value) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeString().value:
          return _stellarBase.xdr.ScVal.scvString(str);
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value:
          return _stellarBase.xdr.ScVal.scvSymbol(str);
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value:
        case _stellarBase.xdr.ScSpecType.scSpecTypeMuxedAddress().value:
          return _stellarBase.Address.fromString(str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
          return new _stellarBase.XdrLargeInt("u64", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
          return new _stellarBase.XdrLargeInt("i64", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
          return new _stellarBase.XdrLargeInt("u128", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
          return new _stellarBase.XdrLargeInt("i128", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
          return new _stellarBase.XdrLargeInt("u256", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value:
          return new _stellarBase.XdrLargeInt("i256", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value:
          return _stellarBase.xdr.ScVal.scvBytes(Buffer.from(str, "base64"));
        case _stellarBase.xdr.ScSpecType.scSpecTypeTimepoint().value: {
          return _stellarBase.xdr.ScVal.scvTimepoint(new _stellarBase.xdr.Uint64(str));
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeDuration().value: {
          return _stellarBase.xdr.ScVal.scvDuration(new _stellarBase.xdr.Uint64(str));
        }
        default:
          throw new TypeError("invalid type ".concat(ty.name, " specified for string value"));
      }
    }
    var PRIMITIVE_DEFINITONS = {
      U32: {
        type: "integer",
        minimum: 0,
        maximum: 4294967295
      },
      I32: {
        type: "integer",
        minimum: -2147483648,
        maximum: 2147483647
      },
      U64: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 20
      },
      Timepoint: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 20
      },
      Duration: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 20
      },
      I64: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 21
      },
      U128: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 39
      },
      I128: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 40
      },
      U256: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 78
      },
      I256: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 79
      },
      Address: {
        type: "string",
        format: "address",
        description: "Address can be a public key or contract id"
      },
      MuxedAddress: {
        type: "string",
        format: "address",
        description: "Stellar public key with M prefix combining a G address and unique ID"
      },
      ScString: {
        type: "string",
        description: "ScString is a string"
      },
      ScSymbol: {
        type: "string",
        description: "ScSymbol is a string"
      },
      DataUrl: {
        type: "string",
        pattern: "^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$"
      }
    };
    function typeRef(typeDef) {
      var t = typeDef.switch();
      var value = t.value;
      var ref;
      switch (value) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeVal().value: {
          ref = "Val";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBool().value: {
          return {
            type: "boolean"
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value: {
          return {
            type: "null"
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeError().value: {
          ref = "Error";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value: {
          ref = "U32";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value: {
          ref = "I32";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value: {
          ref = "U64";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value: {
          ref = "I64";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTimepoint().value: {
          ref = "Timepoint";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeDuration().value: {
          ref = "Duration";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value: {
          ref = "U128";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value: {
          ref = "I128";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value: {
          ref = "U256";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value: {
          ref = "I256";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value: {
          ref = "DataUrl";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeString().value: {
          ref = "ScString";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value: {
          ref = "ScSymbol";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value: {
          ref = "Address";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeMuxedAddress().value: {
          ref = "MuxedAddress";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value: {
          var opt = typeDef.option();
          return typeRef(opt.valueType());
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeResult().value: {
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVec().value: {
          var arr = typeDef.vec();
          var reference = typeRef(arr.elementType());
          return {
            type: "array",
            items: reference
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeMap().value: {
          var map = typeDef.map();
          var items = [typeRef(map.keyType()), typeRef(map.valueType())];
          return {
            type: "array",
            items: {
              type: "array",
              items,
              minItems: 2,
              maxItems: 2
            }
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value: {
          var tuple = typeDef.tuple();
          var minItems = tuple.valueTypes().length;
          var maxItems = minItems;
          var _items = tuple.valueTypes().map(typeRef);
          return {
            type: "array",
            items: _items,
            minItems,
            maxItems
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value: {
          var _arr = typeDef.bytesN();
          return {
            $ref: "#/definitions/DataUrl",
            maxLength: _arr.n()
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value: {
          var udt = typeDef.udt();
          ref = udt.name().toString();
          break;
        }
      }
      return {
        $ref: "#/definitions/".concat(ref)
      };
    }
    function isRequired(typeDef) {
      return typeDef.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeOption().value;
    }
    function argsAndRequired(input) {
      var properties = {};
      var required = [];
      input.forEach(function(arg) {
        var aType = arg.type();
        var name = arg.name().toString();
        properties[name] = typeRef(aType);
        if (isRequired(aType)) {
          required.push(name);
        }
      });
      var res = {
        properties
      };
      if (required.length > 0) {
        res.required = required;
      }
      return res;
    }
    function structToJsonSchema(udt) {
      var fields = udt.fields();
      if (fields.some(isNumeric)) {
        if (!fields.every(isNumeric)) {
          throw new Error("mixed numeric and non-numeric field names are not allowed");
        }
        var items = fields.map(function(_, i) {
          return typeRef(fields[i].type());
        });
        return {
          type: "array",
          items,
          minItems: fields.length,
          maxItems: fields.length
        };
      }
      var description = udt.doc().toString();
      var _argsAndRequired = argsAndRequired(fields), properties = _argsAndRequired.properties, required = _argsAndRequired.required;
      properties.additionalProperties = false;
      return {
        description,
        properties,
        required,
        type: "object"
      };
    }
    function functionToJsonSchema(func) {
      var _argsAndRequired2 = argsAndRequired(func.inputs()), properties = _argsAndRequired2.properties, required = _argsAndRequired2.required;
      var args = {
        additionalProperties: false,
        properties,
        type: "object"
      };
      if ((required === null || required === void 0 ? void 0 : required.length) > 0) {
        args.required = required;
      }
      var input = {
        properties: {
          args
        }
      };
      var outputs = func.outputs();
      var output = outputs.length > 0 ? typeRef(outputs[0]) : typeRef(_stellarBase.xdr.ScSpecTypeDef.scSpecTypeVoid());
      var description = func.doc().toString();
      if (description.length > 0) {
        input.description = description;
      }
      input.additionalProperties = false;
      output.additionalProperties = false;
      return {
        input,
        output
      };
    }
    function unionToJsonSchema(udt) {
      var description = udt.doc().toString();
      var cases = udt.cases();
      var oneOf = [];
      cases.forEach(function(aCase) {
        switch (aCase.switch().value) {
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
            var c = aCase.voidCase();
            var title = c.name().toString();
            oneOf.push({
              type: "object",
              title,
              properties: {
                tag: title
              },
              additionalProperties: false,
              required: ["tag"]
            });
            break;
          }
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
            var _c = aCase.tupleCase();
            var _title = _c.name().toString();
            oneOf.push({
              type: "object",
              title: _title,
              properties: {
                tag: _title,
                values: {
                  type: "array",
                  items: _c.type().map(typeRef)
                }
              },
              required: ["tag", "values"],
              additionalProperties: false
            });
          }
        }
      });
      var res = {
        oneOf
      };
      if (description.length > 0) {
        res.description = description;
      }
      return res;
    }
    var Spec = exports.Spec = (function() {
      function Spec2(entries) {
        _classCallCheck(this, Spec2);
        _defineProperty(this, "entries", []);
        if (Buffer.isBuffer(entries)) {
          this.entries = (0, _utils.processSpecEntryStream)(entries);
        } else if (typeof entries === "string") {
          this.entries = (0, _utils.processSpecEntryStream)(Buffer.from(entries, "base64"));
        } else {
          if (entries.length === 0) {
            throw new Error("Contract spec must have at least one entry");
          }
          var entry = entries[0];
          if (typeof entry === "string") {
            this.entries = entries.map(function(s) {
              return _stellarBase.xdr.ScSpecEntry.fromXDR(s, "base64");
            });
          } else {
            this.entries = entries;
          }
        }
      }
      return _createClass(Spec2, [{
        key: "funcs",
        value: function funcs() {
          return this.entries.filter(function(entry) {
            return entry.switch().value === _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value;
          }).map(function(entry) {
            return entry.functionV0();
          });
        }
      }, {
        key: "getFunc",
        value: function getFunc(name) {
          var entry = this.findEntry(name);
          if (entry.switch().value !== _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value) {
            throw new Error("".concat(name, " is not a function"));
          }
          return entry.functionV0();
        }
      }, {
        key: "funcArgsToScVals",
        value: function funcArgsToScVals(name, args) {
          var _this = this;
          var fn = this.getFunc(name);
          return fn.inputs().map(function(input) {
            return _this.nativeToScVal(readObj(args, input), input.type());
          });
        }
      }, {
        key: "funcResToNative",
        value: function funcResToNative(name, val_or_base64) {
          var val = typeof val_or_base64 === "string" ? _stellarBase.xdr.ScVal.fromXDR(val_or_base64, "base64") : val_or_base64;
          var func = this.getFunc(name);
          var outputs = func.outputs();
          if (outputs.length === 0) {
            var type = val.switch();
            if (type.value !== _stellarBase.xdr.ScValType.scvVoid().value) {
              throw new Error("Expected void, got ".concat(type.name));
            }
            return null;
          }
          if (outputs.length > 1) {
            throw new Error("Multiple outputs not supported");
          }
          var output = outputs[0];
          if (output.switch().value === _stellarBase.xdr.ScSpecType.scSpecTypeResult().value) {
            return new _rust_result.Ok(this.scValToNative(val, output.result().okType()));
          }
          return this.scValToNative(val, output);
        }
      }, {
        key: "findEntry",
        value: function findEntry(name) {
          var entry = this.entries.find(function(e) {
            return e.value().name().toString() === name;
          });
          if (!entry) {
            throw new Error("no such entry: ".concat(name));
          }
          return entry;
        }
      }, {
        key: "nativeToScVal",
        value: function nativeToScVal(val, ty) {
          var _this2 = this;
          var t = ty.switch();
          var value = t.value;
          if (t.value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
            var udt = ty.udt();
            return this.nativeToUdt(val, udt.name().toString());
          }
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeOption().value) {
            var opt = ty.option();
            if (val === null || val === void 0) {
              return _stellarBase.xdr.ScVal.scvVoid();
            }
            return this.nativeToScVal(val, opt.valueType());
          }
          switch (_typeof(val)) {
            case "object": {
              var _val$constructor$name, _val$constructor;
              if (val === null) {
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                    return _stellarBase.xdr.ScVal.scvVoid();
                  default:
                    throw new TypeError("Type ".concat(ty, " was not void, but value was null"));
                }
              }
              if (val instanceof _stellarBase.xdr.ScVal) {
                return val;
              }
              if (val instanceof _stellarBase.Address) {
                if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                  throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
                }
                return val.toScVal();
              }
              if (val instanceof _stellarBase.Contract) {
                if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                  throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
                }
                return val.address().toScVal();
              }
              if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
                var copy = Uint8Array.from(val);
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value: {
                    var bytesN = ty.bytesN();
                    if (copy.length !== bytesN.n()) {
                      throw new TypeError("expected ".concat(bytesN.n(), " bytes, but got ").concat(copy.length));
                    }
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  default:
                    throw new TypeError("invalid type (".concat(ty, ") specified for Bytes and BytesN"));
                }
              }
              if (Array.isArray(val)) {
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeVec().value: {
                    var vec = ty.vec();
                    var elementType = vec.elementType();
                    return _stellarBase.xdr.ScVal.scvVec(val.map(function(v2) {
                      return _this2.nativeToScVal(v2, elementType);
                    }));
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value: {
                    var tup = ty.tuple();
                    var valTypes = tup.valueTypes();
                    if (val.length !== valTypes.length) {
                      throw new TypeError("Tuple expects ".concat(valTypes.length, " values, but ").concat(val.length, " were provided"));
                    }
                    return _stellarBase.xdr.ScVal.scvVec(val.map(function(v2, i) {
                      return _this2.nativeToScVal(v2, valTypes[i]);
                    }));
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeMap().value: {
                    var map = ty.map();
                    var keyType = map.keyType();
                    var valueType = map.valueType();
                    return _stellarBase.xdr.ScVal.scvMap(val.map(function(entry) {
                      var key2 = _this2.nativeToScVal(entry[0], keyType);
                      var mapVal = _this2.nativeToScVal(entry[1], valueType);
                      return new _stellarBase.xdr.ScMapEntry({
                        key: key2,
                        val: mapVal
                      });
                    }));
                  }
                  default:
                    throw new TypeError("Type ".concat(ty, " was not vec, but value was Array"));
                }
              }
              if (val.constructor === Map) {
                if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                  throw new TypeError("Type ".concat(ty, " was not map, but value was Map"));
                }
                var scMap = ty.map();
                var _map = val;
                var entries = [];
                var values = _map.entries();
                var res = values.next();
                while (!res.done) {
                  var _res$value = _slicedToArray(res.value, 2), k = _res$value[0], v = _res$value[1];
                  var key = this.nativeToScVal(k, scMap.keyType());
                  var mapval = this.nativeToScVal(v, scMap.valueType());
                  entries.push(new _stellarBase.xdr.ScMapEntry({
                    key,
                    val: mapval
                  }));
                  res = values.next();
                }
                return _stellarBase.xdr.ScVal.scvMap(entries);
              }
              if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : "") !== "Object") {
                var _val$constructor2;
                throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
              }
              throw new TypeError("Received object ".concat(val, "  did not match the provided type ").concat(ty));
            }
            case "number":
            case "bigint": {
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value:
                  return _stellarBase.xdr.ScVal.scvU32(val);
                case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value:
                  return _stellarBase.xdr.ScVal.scvI32(val);
                case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeTimepoint().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeDuration().value: {
                  var intType = t.name.substring(10).toLowerCase();
                  return new _stellarBase.XdrLargeInt(intType, val).toScVal();
                }
                default:
                  throw new TypeError("invalid type (".concat(ty, ") specified for integer"));
              }
            }
            case "string":
              return stringToScVal(val, t);
            case "boolean": {
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeBool().value) {
                throw TypeError("Type ".concat(ty, " was not bool, but value was bool"));
              }
              return _stellarBase.xdr.ScVal.scvBool(val);
            }
            case "undefined": {
              if (!ty) {
                return _stellarBase.xdr.ScVal.scvVoid();
              }
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value:
                  return _stellarBase.xdr.ScVal.scvVoid();
                default:
                  throw new TypeError("Type ".concat(ty, " was not void, but value was undefined"));
              }
            }
            case "function":
              return this.nativeToScVal(val(), ty);
            default:
              throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
          }
        }
      }, {
        key: "nativeToUdt",
        value: function nativeToUdt(val, name) {
          var entry = this.findEntry(name);
          switch (entry.switch()) {
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              if (typeof val !== "number") {
                throw new TypeError("expected number for enum ".concat(name, ", but got ").concat(_typeof(val)));
              }
              return this.nativeToEnum(val, entry.udtEnumV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.nativeToStruct(val, entry.udtStructV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.nativeToUnion(val, entry.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(name));
          }
        }
      }, {
        key: "nativeToUnion",
        value: function nativeToUnion(val, union_) {
          var _this3 = this;
          var entryName = val.tag;
          var caseFound = union_.cases().find(function(entry) {
            var caseN = entry.value().name().toString();
            return caseN === entryName;
          });
          if (!caseFound) {
            throw new TypeError("no such enum entry: ".concat(entryName, " in ").concat(union_));
          }
          var key = _stellarBase.xdr.ScVal.scvSymbol(entryName);
          switch (caseFound.switch()) {
            case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0(): {
              return _stellarBase.xdr.ScVal.scvVec([key]);
            }
            case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0(): {
              var types = caseFound.tupleCase().type();
              if (Array.isArray(val.values)) {
                if (val.values.length !== types.length) {
                  throw new TypeError("union ".concat(union_, " expects ").concat(types.length, " values, but got ").concat(val.values.length));
                }
                var scvals = val.values.map(function(v, i) {
                  return _this3.nativeToScVal(v, types[i]);
                });
                scvals.unshift(key);
                return _stellarBase.xdr.ScVal.scvVec(scvals);
              }
              throw new Error("failed to parse union case ".concat(caseFound, " with ").concat(val));
            }
            default:
              throw new Error("failed to parse union ".concat(union_, " with ").concat(val));
          }
        }
      }, {
        key: "nativeToStruct",
        value: function nativeToStruct(val, struct) {
          var _this4 = this;
          var fields = struct.fields();
          if (fields.some(isNumeric)) {
            if (!fields.every(isNumeric)) {
              throw new Error("mixed numeric and non-numeric field names are not allowed");
            }
            return _stellarBase.xdr.ScVal.scvVec(fields.map(function(_, i) {
              return _this4.nativeToScVal(val[i], fields[i].type());
            }));
          }
          return _stellarBase.xdr.ScVal.scvMap(fields.map(function(field) {
            var name = field.name().toString();
            return new _stellarBase.xdr.ScMapEntry({
              key: _this4.nativeToScVal(name, _stellarBase.xdr.ScSpecTypeDef.scSpecTypeSymbol()),
              val: _this4.nativeToScVal(val[name], field.type())
            });
          }));
        }
      }, {
        key: "nativeToEnum",
        value: function nativeToEnum(val, enum_) {
          if (enum_.cases().some(function(entry) {
            return entry.value() === val;
          })) {
            return _stellarBase.xdr.ScVal.scvU32(val);
          }
          throw new TypeError("no such enum entry: ".concat(val, " in ").concat(enum_));
        }
      }, {
        key: "scValStrToNative",
        value: function scValStrToNative(scv, typeDef) {
          return this.scValToNative(_stellarBase.xdr.ScVal.fromXDR(scv, "base64"), typeDef);
        }
      }, {
        key: "scValToNative",
        value: function scValToNative(scv, typeDef) {
          var _this5 = this;
          var t = typeDef.switch();
          var value = t.value;
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeOption().value) {
            switch (scv.switch().value) {
              case _stellarBase.xdr.ScValType.scvVoid().value:
                return null;
              default:
                return this.scValToNative(scv, typeDef.option().valueType());
            }
          }
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
            return this.scValUdtToNative(scv, typeDef.udt());
          }
          switch (scv.switch().value) {
            case _stellarBase.xdr.ScValType.scvVoid().value:
              return null;
            case _stellarBase.xdr.ScValType.scvU64().value:
            case _stellarBase.xdr.ScValType.scvI64().value:
            case _stellarBase.xdr.ScValType.scvTimepoint().value:
            case _stellarBase.xdr.ScValType.scvDuration().value:
            case _stellarBase.xdr.ScValType.scvU128().value:
            case _stellarBase.xdr.ScValType.scvI128().value:
            case _stellarBase.xdr.ScValType.scvU256().value:
            case _stellarBase.xdr.ScValType.scvI256().value:
              return (0, _stellarBase.scValToBigInt)(scv);
            case _stellarBase.xdr.ScValType.scvVec().value: {
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeVec().value) {
                var _scv$vec;
                var vec = typeDef.vec();
                return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(function(elm) {
                  return _this5.scValToNative(elm, vec.elementType());
                });
              }
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value) {
                var _scv$vec2;
                var tuple = typeDef.tuple();
                var valTypes = tuple.valueTypes();
                return ((_scv$vec2 = scv.vec()) !== null && _scv$vec2 !== void 0 ? _scv$vec2 : []).map(function(elm, i) {
                  return _this5.scValToNative(elm, valTypes[i]);
                });
              }
              throw new TypeError("Type ".concat(typeDef, " was not vec, but ").concat(scv, " is"));
            }
            case _stellarBase.xdr.ScValType.scvAddress().value:
              return _stellarBase.Address.fromScVal(scv).toString();
            case _stellarBase.xdr.ScValType.scvMap().value: {
              var _scv$map;
              var map = (_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : [];
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                var typed = typeDef.map();
                var keyType = typed.keyType();
                var valueType = typed.valueType();
                var res = map.map(function(entry) {
                  return [_this5.scValToNative(entry.key(), keyType), _this5.scValToNative(entry.val(), valueType)];
                });
                return res;
              }
              throw new TypeError("ScSpecType ".concat(t.name, " was not map, but ").concat(JSON.stringify(scv, null, 2), " is"));
            }
            case _stellarBase.xdr.ScValType.scvBool().value:
            case _stellarBase.xdr.ScValType.scvU32().value:
            case _stellarBase.xdr.ScValType.scvI32().value:
            case _stellarBase.xdr.ScValType.scvBytes().value:
              return scv.value();
            case _stellarBase.xdr.ScValType.scvString().value:
            case _stellarBase.xdr.ScValType.scvSymbol().value: {
              var _scv$value;
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeString().value && value !== _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value) {
                throw new Error("ScSpecType ".concat(t.name, " was not string or symbol, but ").concat(JSON.stringify(scv, null, 2), " is"));
              }
              return (_scv$value = scv.value()) === null || _scv$value === void 0 ? void 0 : _scv$value.toString();
            }
            default:
              throw new TypeError("failed to convert ".concat(JSON.stringify(scv, null, 2), " to native type from type ").concat(t.name));
          }
        }
      }, {
        key: "scValUdtToNative",
        value: function scValUdtToNative(scv, udt) {
          var entry = this.findEntry(udt.name().toString());
          switch (entry.switch()) {
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              return this.enumToNative(scv);
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.structToNative(scv, entry.udtStructV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.unionToNative(scv, entry.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(udt.name().toString(), ": ").concat(entry));
          }
        }
      }, {
        key: "unionToNative",
        value: function unionToNative(val, udt) {
          var _this6 = this;
          var vec = val.vec();
          if (!vec) {
            throw new Error("".concat(JSON.stringify(val, null, 2), " is not a vec"));
          }
          if (vec.length === 0 && udt.cases.length !== 0) {
            throw new Error("".concat(val, " has length 0, but the there are at least one case in the union"));
          }
          var name = vec[0].sym().toString();
          if (vec[0].switch().value !== _stellarBase.xdr.ScValType.scvSymbol().value) {
            throw new Error("{vec[0]} is not a symbol");
          }
          var entry = udt.cases().find(findCase(name));
          if (!entry) {
            throw new Error("failed to find entry ".concat(name, " in union {udt.name().toString()}"));
          }
          var res = {
            tag: name
          };
          if (entry.switch().value === _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value) {
            var tuple = entry.tupleCase();
            var ty = tuple.type();
            var values = ty.map(function(e, i) {
              return _this6.scValToNative(vec[i + 1], e);
            });
            res.values = values;
          }
          return res;
        }
      }, {
        key: "structToNative",
        value: function structToNative(val, udt) {
          var _this7 = this, _val$map;
          var res = {};
          var fields = udt.fields();
          if (fields.some(isNumeric)) {
            var _val$vec;
            var r = (_val$vec = val.vec()) === null || _val$vec === void 0 ? void 0 : _val$vec.map(function(entry, i) {
              return _this7.scValToNative(entry, fields[i].type());
            });
            return r;
          }
          (_val$map = val.map()) === null || _val$map === void 0 || _val$map.forEach(function(entry, i) {
            var field = fields[i];
            res[field.name().toString()] = _this7.scValToNative(entry.val(), field.type());
          });
          return res;
        }
      }, {
        key: "enumToNative",
        value: function enumToNative(scv) {
          if (scv.switch().value !== _stellarBase.xdr.ScValType.scvU32().value) {
            throw new Error("Enum must have a u32 value");
          }
          var num = scv.u32();
          return num;
        }
      }, {
        key: "errorCases",
        value: function errorCases() {
          return this.entries.filter(function(entry) {
            return entry.switch().value === _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value;
          }).flatMap(function(entry) {
            return entry.value().cases();
          });
        }
      }, {
        key: "jsonSchema",
        value: function jsonSchema(funcName) {
          var definitions = {};
          this.entries.forEach(function(entry) {
            switch (entry.switch().value) {
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0().value: {
                var udt = entry.udtEnumV0();
                definitions[udt.name().toString()] = enumToJsonSchema(udt);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0().value: {
                var _udt = entry.udtStructV0();
                definitions[_udt.name().toString()] = structToJsonSchema(_udt);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0().value: {
                var _udt2 = entry.udtUnionV0();
                definitions[_udt2.name().toString()] = unionToJsonSchema(_udt2);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value: {
                var fn = entry.functionV0();
                var fnName = fn.name().toString();
                var _functionToJsonSchema = functionToJsonSchema(fn), input = _functionToJsonSchema.input;
                definitions[fnName] = input;
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value: {
              }
            }
          });
          var res = {
            $schema: "http://json-schema.org/draft-07/schema#",
            definitions: _objectSpread(_objectSpread({}, PRIMITIVE_DEFINITONS), definitions)
          };
          if (funcName) {
            res.$ref = "#/definitions/".concat(funcName);
          }
          return res;
        }
      }], [{
        key: "fromWasm",
        value: function fromWasm(wasm) {
          var spec = (0, _wasm_spec_parser.specFromWasm)(wasm);
          return new Spec2(spec);
        }
      }]);
    })();
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/bindings/utils.js
var require_utils2 = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/bindings/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.formatImports = formatImports;
    exports.formatJSDocComment = formatJSDocComment;
    exports.generateTypeImports = generateTypeImports;
    exports.isNameReserved = isNameReserved;
    exports.isTupleStruct = isTupleStruct;
    exports.parseTypeFromTypeDef = parseTypeFromTypeDef;
    exports.sanitizeIdentifier = sanitizeIdentifier;
    var _stellarBase = require_stellar_base_min();
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function isNameReserved(name) {
      var reservedNames = ["break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "export", "extends", "finally", "for", "function", "if", "import", "in", "instanceof", "new", "return", "super", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "yield", "enum", "implements", "interface", "let", "package", "private", "protected", "public", "static", "async", "await", "constructor", "null", "true", "false"];
      return reservedNames.includes(name);
    }
    function sanitizeIdentifier(identifier) {
      if (isNameReserved(identifier)) {
        return identifier + "_";
      }
      if (/^\d/.test(identifier)) {
        return "_" + identifier;
      }
      return identifier;
    }
    function parseTypeFromTypeDef(typeDef) {
      var isFunctionInput = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      switch (typeDef.switch()) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeVal():
          return "any";
        case _stellarBase.xdr.ScSpecType.scSpecTypeBool():
          return "boolean";
        case _stellarBase.xdr.ScSpecType.scSpecTypeVoid():
          return "null";
        case _stellarBase.xdr.ScSpecType.scSpecTypeError():
          return "Error";
        case _stellarBase.xdr.ScSpecType.scSpecTypeU32():
        case _stellarBase.xdr.ScSpecType.scSpecTypeI32():
          return "number";
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64():
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64():
        case _stellarBase.xdr.ScSpecType.scSpecTypeTimepoint():
        case _stellarBase.xdr.ScSpecType.scSpecTypeDuration():
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128():
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128():
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256():
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256():
          return "bigint";
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes():
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN():
          return "Buffer";
        case _stellarBase.xdr.ScSpecType.scSpecTypeString():
          return "string";
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol():
          return "string";
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress():
        case _stellarBase.xdr.ScSpecType.scSpecTypeMuxedAddress(): {
          if (isFunctionInput) {
            return "string | Address";
          }
          return "string";
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVec(): {
          var vecType = parseTypeFromTypeDef(typeDef.vec().elementType(), isFunctionInput);
          return "Array<".concat(vecType, ">");
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeMap(): {
          var keyType = parseTypeFromTypeDef(typeDef.map().keyType(), isFunctionInput);
          var valueType = parseTypeFromTypeDef(typeDef.map().valueType(), isFunctionInput);
          return "Map<".concat(keyType, ", ").concat(valueType, ">");
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTuple(): {
          var tupleTypes = typeDef.tuple().valueTypes().map(function(t) {
            return parseTypeFromTypeDef(t, isFunctionInput);
          });
          return "[".concat(tupleTypes.join(", "), "]");
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeOption(): {
          while (typeDef.option().valueType().switch() === _stellarBase.xdr.ScSpecType.scSpecTypeOption()) {
            typeDef = typeDef.option().valueType();
          }
          var optionType = parseTypeFromTypeDef(typeDef.option().valueType(), isFunctionInput);
          return "".concat(optionType, " | null");
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeResult(): {
          var okType = parseTypeFromTypeDef(typeDef.result().okType(), isFunctionInput);
          var errorType = parseTypeFromTypeDef(typeDef.result().errorType(), isFunctionInput);
          return "Result<".concat(okType, ", ").concat(errorType, ">");
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeUdt(): {
          var udtName = sanitizeIdentifier(typeDef.udt().name().toString());
          return udtName;
        }
        default:
          return "unknown";
      }
    }
    function extractNestedTypes(typeDef) {
      switch (typeDef.switch()) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeVec():
          return [typeDef.vec().elementType()];
        case _stellarBase.xdr.ScSpecType.scSpecTypeMap():
          return [typeDef.map().keyType(), typeDef.map().valueType()];
        case _stellarBase.xdr.ScSpecType.scSpecTypeTuple():
          return typeDef.tuple().valueTypes();
        case _stellarBase.xdr.ScSpecType.scSpecTypeOption():
          return [typeDef.option().valueType()];
        case _stellarBase.xdr.ScSpecType.scSpecTypeResult():
          return [typeDef.result().okType(), typeDef.result().errorType()];
        default:
          return [];
      }
    }
    function visitTypeDef(typeDef, accumulator) {
      var typeSwitch = typeDef.switch();
      switch (typeSwitch) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeUdt():
          accumulator.typeFileImports.add(sanitizeIdentifier(typeDef.udt().name().toString()));
          return;
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress():
        case _stellarBase.xdr.ScSpecType.scSpecTypeMuxedAddress():
          accumulator.stellarImports.add("Address");
          return;
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes():
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN():
          accumulator.needsBufferImport = true;
          return;
        case _stellarBase.xdr.ScSpecType.scSpecTypeVal():
          accumulator.stellarImports.add("xdr");
          return;
        case _stellarBase.xdr.ScSpecType.scSpecTypeResult():
          accumulator.stellarContractImports.add("Result");
          break;
        case _stellarBase.xdr.ScSpecType.scSpecTypeBool():
        case _stellarBase.xdr.ScSpecType.scSpecTypeVoid():
        case _stellarBase.xdr.ScSpecType.scSpecTypeError():
        case _stellarBase.xdr.ScSpecType.scSpecTypeU32():
        case _stellarBase.xdr.ScSpecType.scSpecTypeI32():
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64():
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64():
        case _stellarBase.xdr.ScSpecType.scSpecTypeTimepoint():
        case _stellarBase.xdr.ScSpecType.scSpecTypeDuration():
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128():
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128():
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256():
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256():
        case _stellarBase.xdr.ScSpecType.scSpecTypeString():
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol():
          return;
      }
      var nestedTypes = extractNestedTypes(typeDef);
      nestedTypes.forEach(function(nested) {
        return visitTypeDef(nested, accumulator);
      });
    }
    function generateTypeImports(typeDefs) {
      var imports = {
        typeFileImports: /* @__PURE__ */ new Set(),
        stellarContractImports: /* @__PURE__ */ new Set(),
        stellarImports: /* @__PURE__ */ new Set(),
        needsBufferImport: false
      };
      typeDefs.forEach(function(typeDef) {
        return visitTypeDef(typeDef, imports);
      });
      return imports;
    }
    function formatImports(imports, options) {
      var importLines = [];
      var typeFileImports = imports.typeFileImports;
      var stellarContractImports = [].concat(_toConsumableArray(imports.stellarContractImports), _toConsumableArray((options === null || options === void 0 ? void 0 : options.additionalStellarContractImports) || []));
      var stellarImports = [].concat(_toConsumableArray(imports.stellarImports), _toConsumableArray((options === null || options === void 0 ? void 0 : options.additionalStellarImports) || []));
      if (options !== null && options !== void 0 && options.includeTypeFileImports && typeFileImports.size > 0) {
        importLines.push("import {".concat(Array.from(typeFileImports).join(", "), "} from './types.js';"));
      }
      if (stellarContractImports.length > 0) {
        var uniqueContractImports = Array.from(new Set(stellarContractImports));
        importLines.push("import {".concat(uniqueContractImports.join(", "), "} from '@stellar/stellar-sdk/contract';"));
      }
      if (stellarImports.length > 0) {
        var uniqueStellarImports = Array.from(new Set(stellarImports));
        importLines.push("import {".concat(uniqueStellarImports.join(", "), "} from '@stellar/stellar-sdk';"));
      }
      if (imports.needsBufferImport) {
        importLines.push("import { Buffer } from 'buffer';");
      }
      return importLines.join("\n");
    }
    function escapeJSDocContent(text) {
      return text.replace(/\*\//g, "* /").replace(/@(?!(param|returns?|type|throws?|example|deprecated|see|link|since|author|version|description|summary)\b)/g, "\\@");
    }
    function formatJSDocComment(comment) {
      var indentLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (comment.trim() === "") {
        return "";
      }
      var indent = " ".repeat(indentLevel);
      var escapedComment = escapeJSDocContent(comment);
      var lines = escapedComment.split("\n").map(function(line) {
        return "".concat(indent, " * ").concat(line).trimEnd();
      });
      return "".concat(indent, "/**\n").concat(lines.join("\n"), "\n").concat(indent, " */\n");
    }
    function isTupleStruct(udtStruct) {
      var fields = udtStruct.fields();
      return fields.every(function(field, index) {
        return field.name().toString().trim() === index.toString();
      });
    }
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/client.js
var require_client = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/client.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Client = void 0;
    var _stellarBase = require_stellar_base_min();
    var _spec = require_spec();
    var _rpc = require_rpc();
    var _assembled_transaction = require_assembled_transaction();
    var _utils = require_utils2();
    var _excluded = ["method"];
    var _excluded2 = ["wasmHash", "salt", "format", "fee", "timeoutInSeconds", "simulate"];
    function _regenerator() {
      var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
      function i(r2, n2, o2, i2) {
        var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
        return _regeneratorDefine2(u2, "_invoke", (function(r3, n3, o3) {
          var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d2(t2, r4) {
            return i3 = t2, c3 = 0, u3 = e, G.n = r4, a;
          } };
          function d(r4, n4) {
            for (c3 = r4, u3 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
              var o4, i4 = p[t], d2 = G.p, l = i4[2];
              r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c3 = 0));
            }
            if (o4 || r4 > 1) return a;
            throw y = true, n4;
          }
          return function(o4, p2, l) {
            if (f2 > 1) throw TypeError("Generator is already running");
            for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
              i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
              try {
                if (f2 = 2, i3) {
                  if (c3 || (o4 = "next"), t = i3[o4]) {
                    if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                    if (!t.done) return t;
                    u3 = t.value, c3 < 2 && (c3 = 0);
                  } else 1 === c3 && (t = i3.return) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                  i3 = e;
                } else if ((t = (y = G.n < 0) ? u3 : r3.call(n3, G)) !== a) break;
              } catch (t2) {
                i3 = e, c3 = 1, u3 = t2;
              } finally {
                f2 = 1;
              }
            }
            return { value: t, done: y };
          };
        })(r2, o2, i2), true), u2;
      }
      var a = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t = Object.getPrototypeOf;
      var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function() {
        return this;
      }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
      function f(e2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function() {
        return this;
      }), _regeneratorDefine2(u, "toString", function() {
        return "[object Generator]";
      }), (_regenerator = function _regenerator2() {
        return { w: i, m: f };
      })();
    }
    function _regeneratorDefine2(e, r, n, t) {
      var i = Object.defineProperty;
      try {
        i({}, "", {});
      } catch (e2) {
        i = 0;
      }
      _regeneratorDefine2 = function _regeneratorDefine(e2, r2, n2, t2) {
        function o(r3, n3) {
          _regeneratorDefine2(e2, r3, function(e3) {
            return this._invoke(r3, n3, e3);
          });
        }
        r2 ? i ? i(e2, r2, { value: n2, enumerable: !t2, configurable: !t2, writable: !t2 }) : e2[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
      }, _regeneratorDefine2(e, r, n, t);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _objectWithoutProperties(e, t) {
      if (null == e) return {};
      var o, r, i = _objectWithoutPropertiesLoose(e, t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
      }
      return t;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var CONSTRUCTOR_FUNC = "__constructor";
    function specFromWasmHash(_x, _x2) {
      return _specFromWasmHash.apply(this, arguments);
    }
    function _specFromWasmHash() {
      _specFromWasmHash = _asyncToGenerator(_regenerator().m(function _callee5(wasmHash, options) {
        var format, rpcUrl, allowHttp, headers, serverOpts, server, wasm, _args5 = arguments;
        return _regenerator().w(function(_context5) {
          while (1) switch (_context5.n) {
            case 0:
              format = _args5.length > 2 && _args5[2] !== void 0 ? _args5[2] : "hex";
              if (!(!options || !options.rpcUrl)) {
                _context5.n = 1;
                break;
              }
              throw new TypeError("options must contain rpcUrl");
            case 1:
              rpcUrl = options.rpcUrl, allowHttp = options.allowHttp, headers = options.headers;
              serverOpts = {
                allowHttp,
                headers
              };
              server = new _rpc.Server(rpcUrl, serverOpts);
              _context5.n = 2;
              return server.getContractWasmByHash(wasmHash, format);
            case 2:
              wasm = _context5.v;
              return _context5.a(2, _spec.Spec.fromWasm(wasm));
          }
        }, _callee5);
      }));
      return _specFromWasmHash.apply(this, arguments);
    }
    var Client = exports.Client = (function() {
      function Client2(spec, options) {
        var _this = this;
        _classCallCheck(this, Client2);
        _defineProperty(this, "txFromJSON", function(json) {
          var _JSON$parse = JSON.parse(json), method = _JSON$parse.method, tx = _objectWithoutProperties(_JSON$parse, _excluded);
          return _assembled_transaction.AssembledTransaction.fromJSON(_objectSpread(_objectSpread({}, _this.options), {}, {
            method,
            parseResultXdr: function parseResultXdr(result) {
              return _this.spec.funcResToNative(method, result);
            }
          }), tx);
        });
        _defineProperty(this, "txFromXDR", function(xdrBase64) {
          return _assembled_transaction.AssembledTransaction.fromXDR(_this.options, xdrBase64, _this.spec);
        });
        this.spec = spec;
        this.options = options;
        if (options.server === void 0) {
          var allowHttp = options.allowHttp, headers = options.headers;
          options.server = new _rpc.Server(options.rpcUrl, {
            allowHttp,
            headers
          });
        }
        this.spec.funcs().forEach(function(xdrFn) {
          var method = xdrFn.name().toString();
          if (method === CONSTRUCTOR_FUNC) {
            return;
          }
          var assembleTransaction = function assembleTransaction2(args, methodOptions) {
            return _assembled_transaction.AssembledTransaction.build(_objectSpread(_objectSpread(_objectSpread({
              method,
              args: args && spec.funcArgsToScVals(method, args)
            }, options), methodOptions), {}, {
              errorTypes: spec.errorCases().reduce(function(acc, curr) {
                return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, curr.value(), {
                  message: curr.doc().toString()
                }));
              }, {}),
              parseResultXdr: function parseResultXdr(result) {
                return spec.funcResToNative(method, result);
              }
            }));
          };
          _this[(0, _utils.sanitizeIdentifier)(method)] = spec.getFunc(method).inputs().length === 0 ? function(opts) {
            return assembleTransaction(void 0, opts);
          } : assembleTransaction;
        });
      }
      return _createClass(Client2, null, [{
        key: "deploy",
        value: (function() {
          var _deploy = _asyncToGenerator(_regenerator().m(function _callee(args, options) {
            var wasmHash, salt, format, fee, timeoutInSeconds, simulate, clientOptions, spec, operation;
            return _regenerator().w(function(_context) {
              while (1) switch (_context.n) {
                case 0:
                  wasmHash = options.wasmHash, salt = options.salt, format = options.format, fee = options.fee, timeoutInSeconds = options.timeoutInSeconds, simulate = options.simulate, clientOptions = _objectWithoutProperties(options, _excluded2);
                  _context.n = 1;
                  return specFromWasmHash(wasmHash, clientOptions, format);
                case 1:
                  spec = _context.v;
                  operation = _stellarBase.Operation.createCustomContract({
                    address: new _stellarBase.Address(options.address || options.publicKey),
                    wasmHash: typeof wasmHash === "string" ? Buffer.from(wasmHash, format !== null && format !== void 0 ? format : "hex") : wasmHash,
                    salt,
                    constructorArgs: args ? spec.funcArgsToScVals(CONSTRUCTOR_FUNC, args) : []
                  });
                  return _context.a(2, _assembled_transaction.AssembledTransaction.buildWithOp(operation, _objectSpread(_objectSpread({
                    fee,
                    timeoutInSeconds,
                    simulate
                  }, clientOptions), {}, {
                    contractId: "ignored",
                    method: CONSTRUCTOR_FUNC,
                    parseResultXdr: function parseResultXdr(result) {
                      return new Client2(spec, _objectSpread(_objectSpread({}, clientOptions), {}, {
                        contractId: _stellarBase.Address.fromScVal(result).toString()
                      }));
                    }
                  })));
              }
            }, _callee);
          }));
          function deploy(_x3, _x4) {
            return _deploy.apply(this, arguments);
          }
          return deploy;
        })()
      }, {
        key: "fromWasmHash",
        value: (function() {
          var _fromWasmHash = _asyncToGenerator(_regenerator().m(function _callee2(wasmHash, options) {
            var _options$server;
            var format, rpcUrl, allowHttp, headers, server, wasm, _args2 = arguments;
            return _regenerator().w(function(_context2) {
              while (1) switch (_context2.n) {
                case 0:
                  format = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : "hex";
                  if (!(!options || !options.rpcUrl)) {
                    _context2.n = 1;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl");
                case 1:
                  rpcUrl = options.rpcUrl, allowHttp = options.allowHttp, headers = options.headers;
                  server = (_options$server = options.server) !== null && _options$server !== void 0 ? _options$server : new _rpc.Server(rpcUrl, {
                    allowHttp,
                    headers
                  });
                  _context2.n = 2;
                  return server.getContractWasmByHash(wasmHash, format);
                case 2:
                  wasm = _context2.v;
                  return _context2.a(2, Client2.fromWasm(wasm, options));
              }
            }, _callee2);
          }));
          function fromWasmHash(_x5, _x6) {
            return _fromWasmHash.apply(this, arguments);
          }
          return fromWasmHash;
        })()
      }, {
        key: "fromWasm",
        value: (function() {
          var _fromWasm = _asyncToGenerator(_regenerator().m(function _callee3(wasm, options) {
            var spec;
            return _regenerator().w(function(_context3) {
              while (1) switch (_context3.n) {
                case 0:
                  _context3.n = 1;
                  return _spec.Spec.fromWasm(wasm);
                case 1:
                  spec = _context3.v;
                  return _context3.a(2, new Client2(spec, options));
              }
            }, _callee3);
          }));
          function fromWasm(_x7, _x8) {
            return _fromWasm.apply(this, arguments);
          }
          return fromWasm;
        })()
      }, {
        key: "from",
        value: (function() {
          var _from = _asyncToGenerator(_regenerator().m(function _callee4(options) {
            var rpcUrl, contractId, allowHttp, headers, server, wasm;
            return _regenerator().w(function(_context4) {
              while (1) switch (_context4.n) {
                case 0:
                  if (!(!options || !options.rpcUrl || !options.contractId)) {
                    _context4.n = 1;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl and contractId");
                case 1:
                  rpcUrl = options.rpcUrl, contractId = options.contractId, allowHttp = options.allowHttp, headers = options.headers;
                  server = new _rpc.Server(rpcUrl, {
                    allowHttp,
                    headers
                  });
                  _context4.n = 2;
                  return server.getContractWasmByContractId(contractId);
                case 2:
                  wasm = _context4.v;
                  return _context4.a(2, Client2.fromWasm(wasm, options));
              }
            }, _callee4);
          }));
          function from(_x9) {
            return _from.apply(this, arguments);
          }
          return from;
        })()
      }]);
    })();
  }
});

// src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/index.js
var require_contract = __commonJS({
  "src/contracts/battleship/node_modules/@stellar/stellar-sdk/lib/contract/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _assembled_transaction = require_assembled_transaction();
    Object.keys(_assembled_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _assembled_transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _assembled_transaction[key];
        }
      });
    });
    var _basic_node_signer = require_basic_node_signer();
    Object.keys(_basic_node_signer).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _basic_node_signer[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _basic_node_signer[key];
        }
      });
    });
    var _client = require_client();
    Object.keys(_client).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _client[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _client[key];
        }
      });
    });
    var _rust_result = require_rust_result();
    Object.keys(_rust_result).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _rust_result[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _rust_result[key];
        }
      });
    });
    var _sent_transaction = require_sent_transaction();
    Object.keys(_sent_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _sent_transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _sent_transaction[key];
        }
      });
    });
    var _spec = require_spec();
    Object.keys(_spec).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _spec[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _spec[key];
        }
      });
    });
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
  }
});
export default require_contract();
//# sourceMappingURL=@stellar_stellar-sdk_contract.js.map
